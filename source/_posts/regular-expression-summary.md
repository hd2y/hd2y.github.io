---
title: "正则表达式总结"
date: "2019/04/05 19:25:00"
updated: "2019/04/05 19:25:00"
permalink: "regular-expression-summary"
tags:
 - 正则
categories:
 - [开发, C#]
---

## 正则表达式

正则表达式作为一个强大的字符串处理方案，一直受到广大程序员的青睐。其不但使用灵活，而且字符串处理的速度也基本被各种编程语言优化到极致，在字符串匹配、提取、替换、分割等一直是首选的方案。

最近有一个前端妹子突然问了一个非常简单的正则表达式应该怎么写，我诧异于她不会写正则表达式的同时，思考了一下好像身边同事，真会使用正则表达式的也没有几个。

恰好最近在读《JavaScript面向对象编程指南》这本书的`RegExp`（JavaScript中的正则表达式对象）这一章，那就趁此机会总结一下平时工作学习中使用正则表达式的场景，同时整理一下这部分的基本知识。

> 本文代码均使用 `C#` 编写，后面有空会针对不同的编程语言，介绍各自的正则表达式对象怎么使用。

## 校验

正则我们使用最多就是校验了，也就是对一个字符串进行匹配，确认一个字符串是否符合要求，例如判断一个IP是否合法、用户名是否符合系统要求、邮箱输入合法、输入内容是否是数字等。

### 从用户名校验开始

经常能看到一些网站或系统中，设计用户名规则为：“只能使用数字或英文，并且首字母必须是字母，长度限制在6-32以内”。

如果没有正则表达式，代码的实现我们可能需要这么设计：循环字符串中每一个字符，判断其是否符合限制要求。

```csharp
/// <summary>
/// 验证用户名是否合法：6-32位字母数字组成，首字母非数字
/// </summary>
/// <param name="name">用户名</param>
/// <returns>用户名是否符合系统设计规则要求</returns>
public static bool CheckUserName(string name)
{
    //验证长度限制
    if (name.Length < 6 || name.Length > 32)
        return false;

    for (int i = 0; i < name.Length; i++)
    {
        char ch = name[i];

        //必须是数字或大小写字母
        if (ch < 48 || ch > 57 && ch < 65 || ch > 95 && ch < 97)
            return false;

        //首字母不能是数字
        if (i == 0 && ch >= 48 && ch <= 57)
            return false;
    }
    return true;
}
```

以上已经尽量优化，用字符对应的编码字符来判断是否在数字或大小写字母的编码区间内，小明同学看了表示这个已经不错了，但是如果我们用正则表示呢？

```csharp
/// <summary>
/// 验证用户名是否合法：6-32位字母数字组成，首字母非数字
/// </summary>
/// <param name="name">用户名</param>
/// <returns>用户名是否符合系统设计规则要求</returns>
public static bool CheckUserName(string name)
{
    return System.Text.RegularExpressions.Regex.IsMatch(name, "^[a-zA-Z][a-zA-Z0-9]{5,31}$");
}
```

只需要一行代码，就可以实现上面对于用户名的校验，当然这还只是简单的用户名校验问题，如果是针对更复杂的例如IP地址/身份证/手机号码/邮箱/网址等，正则的优势还会更明显，因为这些内容我们同样可以使用一个正则表达式来实现匹配校验。

### 常用的正则表达式

转自：[最全的常用正则表达式大全——包括校验数字、字符、一些特殊的需求等等](http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html)

#### 校验数字的表达式

 1. 数字：`^[0-9]*$`
 2. n位的数字：`^\d{n}$`
 3. 至少n位的数字：`^\d{n,}$`
 4. m-n位的数字：`^\d{m,n}$`
 5. 零和非零开头的数字：`^(0|[1-9][0-9]*)$`
 6. 非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(.[0-9]{1,2})?$`
 7. 带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})?$`
 8. 正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`
 9. 有两位小数的正实数：`^[0-9]+(.[0-9]{2})?$`
10. 有1~3位小数的正实数：`^[0-9]+(.[0-9]{1,3})?$`
11. 非零的正整数：`^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$`
12. 非零的负整数：`^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$`
13. 非负整数：`^\d+$ 或 ^[1-9]\d*|0$`
14. 非正整数：`^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$`
15. 非负浮点数：`^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`
16. 非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`
17. 正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`
18. 负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`
19. 浮点数：`^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`

#### 校验字符的表达式

 1. 汉字：`^[\u4e00-\u9fa5]{0,}$`
 2. 英文和数字：`^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$`
 3. 长度为3-20的所有字符：`^.{3,20}$`
 4. 由26个英文字母组成的字符串：`^[A-Za-z]+$`
 5. 由26个大写英文字母组成的字符串：`^[A-Z]+$`
 6. 由26个小写英文字母组成的字符串：`^[a-z]+$`
 7. 由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`
 8. 由数字、26个英文字母或者下划线组成的字符串：`^\w+$ 或 ^\w{3,20}$`
 9. 中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`
10. 中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`
11. 可以输入含有^%&',;=?$\"等字符：`[^%&',;=?$\x22]+`
12. 禁止输入含有~的字符：`[^~\x22]+`

#### 特殊需求表达式

 1. Email地址：`^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$`
 2. 域名：`[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?`
 3. InternetURL：`[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$`
 4. 手机号码：`^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\d{8}$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\d{9}$)`
 5. 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：`^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$`
 6. 国内电话号码(0511-4405222、021-87888822)：`\d{3}-\d{8}|\d{4}-\d{7}`
 7. 18位身份证号码(数字、字母x结尾)：`^((\d{18})|([0-9x]{18})|([0-9X]{18}))$`
 8. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$`
 9. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：`^[a-zA-Z]\w{5,17}$`
10. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`
11. 日期格式：`^\d{4}-\d{1,2}-\d{1,2}`
12. 一年的12个月(01～09和1～12)：`^(0?[1-9]|1[0-2])$`
13. 一个月的31天(01～09和1～31)：`^((0?[1-9])|((1|2)[0-9])|30|31)$`
14. 钱的输入格式：
   1. 有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：`^[1-9][0-9]*$`
   2. 这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：`^(0|[1-9][0-9]*)$`
   3. 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：`^(0|-?[1-9][0-9]*)$`
   4. 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：`^[0-9]+(.[0-9]+)?$`
   5. 必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：`^[0-9]+(.[0-9]{2})?$`
   6. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：`^[0-9]+(.[0-9]{1,2})?$`
   7. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：`^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$`
   8. 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：`^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$`
15. xml文件：`^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$`
16. 中文字符的正则表达式：`[\u4e00-\u9fa5]`
17. 双字节字符：`[^\x00-\xff]`    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
18. 空白行的正则表达式：`\n\s*\r`    (可以用来删除空白行)
19. HTML标记的正则表达式：`<(\S*?)[^>]*>.*?</\1>|<.*? />`    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
20. 首尾空白字符的正则表达式：`^\s*|\s*$或(^\s*)|(\s*$)`    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
21. 腾讯QQ号：`[1-9][0-9]{4,}`    (腾讯QQ号从10000开始)
22. 中国邮政编码：`[1-9]\d{5}(?!\d)`    (中国邮政编码为6位数字)
23. IP地址：`((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))`

以上是一些网上流传的正则表达式，这些内容仅供参考，如果想要确认以上正则表达式是否符合自己的使用场景，或者自己实现一个正则表达式，请看最后一个部分。


## 提取

提取顾名思义也就是从一段字符串，获取我们需要的特定内容，例如在网页爬虫中，我们常常需要获取html中的文本内容，或特定标签下的内容。（当然我们可以使用`XPath`语法进行解析，但是正则也不失为一个优秀的解决方案，而且很多XPath方案的底层是基于正则实现的。后面介绍爬虫的时候，再具体介绍XPath。）

如果内容是我们需要提取的内容，我们可以使用`(` `)`将需要提取的内容包起来，这样正则匹配时会将这部分内容提取到集合中，我们可以从集合中获取这些元素。

### 提取邮箱中的用户名

C# 中，提取到的内容在Group集合中，集合中第一个元素为匹配的所有内容，例如下面代码第一个元素是匹配到的邮箱，而后的元素才是我们使用小括号提取的内容。

```csharp
/// <summary>
/// 验证邮箱并提取邮箱中的用户名
/// </summary>
/// <param name="email">邮箱</param>
/// <param name="name">用户名</param>
/// <returns>邮箱内容是否合法</returns>
public static bool CheckEmail(string email, out string name)
{
    name = null;
    System.Text.RegularExpressions.Match match 
        = System.Text.RegularExpressions.Regex.Match(email, @"^(\w+([-+.]\w+)*)@\w+([-.]\w+)*\.\w+([-.]\w+)*$");

    if (match.Success)
    {
        name = match.Groups[1].Value;
    }

    return match.Success;
}
```

简单测试：

```csharp
string email = "hd2y@outlook.com";
if (CheckEmail(email, out string name))
{
    Console.WriteLine($"用户{name}邮箱验证合法：{email}");
}
```

### 提取Html内容中所有标题

在邮箱匹配的例子中我们对内容进行了限定，`^`代表匹配开头，`$`代表匹配结尾，所以其实际上是对整个内容进行匹配。

但是我们可能会碰到对内容进行多次匹配的情况，例如提取html内容中所有的标题也就是h1-h6标签，这就是一个循环匹配的过程，所以我们不能限定开始于结束。

另外一个标签有标签名、属性、内容，当让我们可以使用上文的方式，在匹配到的内容通过索引去获取内容，但是正则也允许我们使用别名，所以以下的例子中，我们将为其取别名，然后通过别名来获取内容。同时我们还可以使用别名配合`\k`(命名向后引用)来确定一个标签的闭合。

```csharp
public static IEnumerable<Title> FetchTitle(string title)
{
    foreach (System.Text.RegularExpressions.Match item
        in System.Text.RegularExpressions.Regex.Matches(title, @"<(?'TN'H[1-6])\s*(?'TP'[^<>]*)>(?'TC'.*?)</\k'TN'>"
           , System.Text.RegularExpressions.RegexOptions.IgnoreCase))
    {
        yield return new Title()
        {
            Name = item.Groups["TN"].Value,
            Property = item.Groups["TP"].Value,
            Content = item.Groups["TC"].Value
        };
    }
}

public class Title
{
    public string Name { get; set; }
    public string Property { get; set; }
    public string Content { get; set; }
}
```

简单测试：

```csharp
string html = "<h1>h1</h1><h2>h2</h2><h3>h3</h3><h4>h4</h4><h5 style=\"color:red;\">h5</h5><h6>h6</h6>";
foreach (Title title in FetchTitle(html))
{
    Console.WriteLine($"获取到标题{title.Name} 内容：{title.Content} 属性：{title.Property}");
}
```

> 以上匹配部分写法并不严格，例如标题标签嵌套其他标签内容时可能存在问题，这里只是简单举例，不考虑复杂正则表达式写法。

> Html内容提取可以参考 [Aiursoft.HSharp](https://github.com/Anduin2017/HSharp) 项目，里面对于Html的解析较为标准可用。

## 分割

对于字符串操作，大部分编程语言都提供了Split方法，同样的正则也有类似的方法，但是正则分割适用范围更广，适合在分隔符不确定但是有一定规律的情况下使用。

### 分割时间信息

```csharp
string[] dateInfo = Regex.Split("2019-04-01 00:00:00", @"\W");
```

### 提取Pascal方法名中的单词

```csharp
string[] words = Regex.Split("ILoveYou", "(?!^)(?=[A-Z])");
```

> `(?!...)` 正向否定预查；`(?=...)` 正向肯定预查。

## 替换

在我的日常工作中，正则使用频率一般是 匹配 > 提取 > 替换 > 分割，替换在一些特定环境下，真的是让人有种相见恨晚的感觉。

### 处理ASTM协议消息

在工作中有时会和其他系统和设备打交道，做一些接口，他们都有自己定义的通讯协议，而ASTM就是其中一种。

刚开始处理这个协议的一个问题就在于，这个协议会将完整的消息分块，然后加入校验字符，类似下面这种结果：（以下内容仅仅是简单举例，验证内容未经实际计算，ASTM协议更多解释可以搜索相关文档了解）

```
<STX>1AAA<ETB>1F<CR><LF>
<STX>2BBB<ETB>2E<CR><LF>
<STX>3CCC<ETX>3D<CR><LF>
```

其中我们需要的只是其中的AAABBBCCC，但是其为了确认消息的完整性加入了一些消息块标识和校验码，这些不是我们需要的但是使用字符串自带的Replace或者Split取消息部分就比较麻烦，至少需要写一个循环。

而正则就相对简单的多：

```csharp
string content = "";//内容略
content = Regex.Replace(content, @"(\u0002[0-7]{1})|((\u0003|\u0017)[0-9A-F]{2}\r\n)", "");
```

### 删除重复单词

```csharp
string content = "I love you very very very much.";//内容略
content = Regex.Replace(content, @"(?<word>[a-zA-Z]+)( \k<word>)+", "${word}");
```

以上只是一些使用场景的简单举例，以下部分时摘抄自菜鸟教程关于正则表达式部分的文档，供学习或者查阅时使用。

## 语法

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

例如：
+ `runoo+b`，可以匹配 runoob、runooob、runoooooob 等，`+` 号代表前面的字符必须至少出现一次（1次或多次）。
+ `runoo*b`，可以匹配 runob、runoob、runoooooob 等，`*` 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。
+ `colou?r` 可以匹配 color 或者 colour，`?` 问号代表前面的字符最多只可以出现一次（0次、或1次）。

构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。

### 普通字符

普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

### 非打印字符

非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

| 字符 | 描述 |
|:-----|:-----|
|\cx | 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。|
|\f	 | 匹配一个换页符。等价于 \x0c 和 \cL。|
|\n	 | 匹配一个换行符。等价于 \x0a 和 \cJ。|
|\r	 | 匹配一个回车符。等价于 \x0d 和 \cM。|
|\s	 | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 `[ \f\n\r\t\v]`。注意 Unicode 正则表达式会匹配全角空格符。|
|\S	 | 匹配任何非空白字符。等价于 `[^ \f\n\r\t\v]`。|
|\t	 | 匹配一个制表符。等价于 \x09 和 \cI。|
|\v	 | 匹配一个垂直制表符。等价于 \x0b 和 \cK。|

### 特殊字符

所谓特殊字符，就是一些有特殊含义的字符，如上面说的 `runoo*b` 中的 `*`，简单的说就是表示任何字符串的意思。如果要查找字符串中的 `*` 符号，则需要对 `*` 进行转义，即在其前加一个 `\`: `runo\*ob` 匹配 `runo*ob`。

许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：

| 特别字符 | 描述 |
|:---------|:-----|
|$   |匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。|
|( ) |标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。|
|*   |匹配前面的子表达式零次或多次。要匹配 `*` 字符，请使用 `\*`。|
|+   |匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。|
|.   |匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。|
|`[`   |标记一个中括号表达式的开始。要匹配 `[`，请使用 `\[`。|
|?   |匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。|
|\   |将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。|
|^   |匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。|
|{   |标记限定符表达式的开始。要匹配 {，请使用 \{。|
||   |指明两项之间的一个选择。要匹配 |，请使用 \|。|

### 限定符

限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 `*` 或 `+` 或 `?` 或 `{n}` 或 `{n,}` 或 `{n,m}` 共6种。

正则表达式的限定符有：

| 字符 | 描述 |
|:-----|:-----|
|*    |匹配前面的子表达式零次或多次。例如，`zo*` 能匹配 "z" 以及 "zoo"。`*` 等价于{0,}。
|+    |匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
|?    |匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。
|{n}  |n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
|{n,} |n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
|{n,m}|m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。

## 元字符

下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：

| 字符 | 描述 |
|:-----|:-----|
\          |将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'\n' 匹配一个换行符。序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。
^          |匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。
$          |匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。
*          |匹配前面的子表达式零次或多次。例如，`zo*` 能匹配 "z" 以及 "zoo"。`*` 等价于{0,}。
+          |匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
?          |匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。
{n}        |n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,}       |n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 `'o*'`。
{n,m}      |m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
?          |当该字符紧跟在任何一个其他限制符 (`*`, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。
.          |匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。
(pattern)  |匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '\(' 或 '\)'。
(?:pattern)|匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。
(?=pattern)|正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern)|正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?<=pattern)|反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，"(?<=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。
(?<!pattern)|反向否定预查，与正向否定预查类似，只是方向相反。例如"(?<!95|98|NT|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。
x|y        |匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
`[xyz]`      |字符集合。匹配所包含的任意一个字符。例如， `'[abc]'` 可以匹配 "plain" 中的 'a'。
`[^xyz]`     |负值字符集合。匹配未包含的任意字符。例如， `'[^abc]'` 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。
`[a-z]`      |字符范围。匹配指定范围内的任意字符。例如，`'[a-z]'` 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
`[^a-z]`     |负值字符范围。匹配任何不在指定范围内的任意字符。例如，`'[^a-z]'` 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。
\b         |匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
\B         |匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
\cx        |匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\d         |匹配一个数字字符。等价于 `[0-9]`。
\D         |匹配一个非数字字符。等价于 `[^0-9]`。
\f         |匹配一个换页符。等价于 \x0c 和 \cL。
\n         |匹配一个换行符。等价于 \x0a 和 \cJ。
\r         |匹配一个回车符。等价于 \x0d 和 \cM。
\s         |匹配任何空白字符，包括空格、制表符、换页符等等。等价于 `[ \f\n\r\t\v]`。
\S         |匹配任何非空白字符。等价于 `[^ \f\n\r\t\v]`。
\t         |匹配一个制表符。等价于 \x09 和 \cI。
\v         |匹配一个垂直制表符。等价于 \x0b 和 \cK。
\w         |匹配字母、数字、下划线。等价于`'[A-Za-z0-9_]'`。
\W         |匹配非字母、数字、下划线。等价于 `'[^A-Za-z0-9_]'`。
\xn        |匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'\x41' 匹配 "A"。'\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。
\num       |匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)\1' 匹配两个连续的相同字符。
\n         |标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
\nm        | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
\nml       |如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
\un        |匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号。
