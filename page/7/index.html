<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>华灯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="盈月舞清风，华灯自摇曳。">
<meta property="og:type" content="website">
<meta property="og:title" content="华灯">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="华灯">
<meta property="og:description" content="盈月舞清风，华灯自摇曳。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="hd2y">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="华灯" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">华灯</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-attribute" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/attribute" class="article-date">
  <time class="dt-published" datetime="2019-04-06T05:24:00.000Z" itemprop="datePublished">2019-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/attribute">Attribute特性简介</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Attribute-特性"><a href="#Attribute-特性" class="headerlink" title="Attribute 特性"></a>Attribute 特性</h2><h3 id="特性简介"><a href="#特性简介" class="headerlink" title="特性简介"></a>特性简介</h3><p>特性（<code>Attribute</code>）是用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（<code>[ ]</code>）来描述的。  </p>
<p> 特性（<code>Attribute</code>）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。<code>.Net</code> 框架提供了两种类型的特性：预定义特性和自定义特性。  </p>
<p><strong>与注释的区别：</strong> 注释仅在 <code>IDE</code> 环境中使用，特性可以影响编译器或程序运行，可以在不破坏类型封装的前提下，为对象增加额外的信息，执行额外的行为。</p>
<h3 id="特性语法"><a href="#特性语法" class="headerlink" title="特性语法"></a>特性语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">attribute(positional_parameters, name_parameter = value, ...)</span>]  </span><br><span class="line">element</span><br></pre></td></tr></table></figure>
<p>特性（<code>Attribute</code>）的名称和值是在方括号内规定的，放置在它所应用的元素之前。<code>positional_parameters</code> 规定必需的信息，<code>name_parameter</code> 规定可选的信息。</p>
<h2 id="预定义特性"><a href="#预定义特性" class="headerlink" title="预定义特性"></a>预定义特性</h2><h3 id="AttributeUsage"><a href="#AttributeUsage" class="headerlink" title="AttributeUsage"></a><code>AttributeUsage</code></h3><p>预定义特性 <code>AttributeUsage</code> 描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(validon, AllowMultiple=allowmultiple, Inherited=inherited)</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>参数 <code>validon</code> 规定特性可被放置的语言元素。它是枚举器 AttributeTargets 的值的组合。默认值是 <code>AttributeTargets.All</code>。  </li>
<li>参数 <code>allowmultiple</code>（可选的）为该特性的 <code>AllowMultiple</code> 属性（<code>property</code>）提供一个布尔值。如果为 <code>true</code>，则该特性是多用的。默认值是 <code>false</code>（单用的）。  </li>
<li>参数 <code>inherited</code>（可选的）为该特性的 <code>Inherited</code> 属性（<code>property</code>）提供一个布尔值。如果为 <code>true</code>，则该特性可被派生类继承。默认值是 <code>false</code>（不被继承）。</li>
</ul>
<p>例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | ttributeTargets.Constructor | AttributeTargets.Field | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a><code>Conditional</code></h3><p>这个预定义特性标记了一个条件方法，其执行依赖于它顶的预处理标识符。它会引起方法调用的条件编译，取决于指定的值，比如 <code>Debug</code> 或 <code>Trace</code>。例如，当调试代码时显示变量的值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Conditional(conditionalSymbol)</span>]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;DEBUG&quot;</span>)</span>]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> <code>Conditional</code> 特性的方式与 <code>#if...#endif</code>，<code>Conditional</code> 特性的方法是否生效是取决于调用方，而用 <code>#if</code> 方式是否生效是取决于方法定义所在的程序集。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;Conditional&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestOne</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要设置项目 属性 -&gt; 生成 -&gt; 条件编译符号 为：Conditional</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;this is test function one.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TestTwo</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//需要设置项目 属性 -&gt; 生成 -&gt; 条件编译符号 为：Conditional</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> Conditional</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;this is test function two.&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>Conditional</code> 特性可以多个，同时使用多个多个编译符号，多个之间是“或”的关系。</p>
<h3 id="Obsolete"><a href="#Obsolete" class="headerlink" title="Obsolete"></a>Obsolete</h3><p>这个预定义特性标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 <code>obsolete</code>（过时的）。  </p>
<p>规定该特性的语法如下：</p>
<p><code>[Obsolete(message)]</code> 或 <code>[Obsolete(message, iserror)]</code>  </p>
<ul>
<li>参数 <code>message</code>，是一个字符串，描述项目为什么过时的原因以及该替代使用什么。  </li>
<li>参数 <code>iserror</code>，是一个布尔值。如果该值为 <code>true</code>，编译器应把该项目的使用当作一个错误。默认值是 <code>false</code>（编译器生成一个警告）。</li>
</ul>
<h2 id="自定义特性"><a href="#自定义特性" class="headerlink" title="自定义特性"></a>自定义特性</h2><p><code>.Net</code> 框架允许创建自定义特性，用于存储声明性的信息，且可在运行时被检索。该信息根据设计标准和应用程序需要，可与任何目标元素相关。  </p>
<p>创建并使用自定义特性包含四个步骤：</p>
<ul>
<li>声明自定义特性；构建自定义特性；</li>
<li>在目标程序元素上应用自定义特性；</li>
<li>通过反射访问特性；</li>
<li>最后一个步骤包含编写一个简单的程序来读取元数据以便查找各种符号。元数据是用于描述其他数据的数据和信息。该程序应使用反射来在运行时访问特性。</li>
</ul>
<h3 id="声明自定义特性"><a href="#声明自定义特性" class="headerlink" title="声明自定义特性"></a>声明自定义特性</h3><p>一个新的自定义特性应派生自 System.Attribute 类。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Field | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeveloperInfoAttribute</span> : <span class="title">Attribute</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建自定义特性"><a href="#构建自定义特性" class="headerlink" title="构建自定义特性"></a>构建自定义特性</h3><p>每个特性必须至少有一个构造函数。必需的定位（<code>positional</code>）参数应通过构造函数传递。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Field | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeveloperInfoAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeveloperInfoAttribute</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> date</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        DeveloperName = name;</span><br><span class="line">        DeveloperDate = date;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> DeveloperName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> DeveloperDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Describe &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用自定义特性"><a href="#应用自定义特性" class="headerlink" title="应用自定义特性"></a>应用自定义特性</h3><p>通过把特性放置在紧接着它的目标之前，来应用该特性。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">DeveloperInfo(<span class="meta-string">&quot;John&quot;</span>, <span class="meta-string">&quot;2018-06-23&quot;</span>, Describe = <span class="meta-string">&quot;this is a test class.&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Business</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DeveloperInfo(<span class="meta-string">&quot;John&quot;</span>, <span class="meta-string">&quot;2018-06-23&quot;</span>, Describe = <span class="meta-string">&quot;this is a test property.&quot;</span>)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> TestProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    [<span class="meta">DeveloperInfo(<span class="meta-string">&quot;John&quot;</span>, <span class="meta-string">&quot;2018-06-23&quot;</span>, Describe = <span class="meta-string">&quot;this is a test method.&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestMethod</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过反射访问特性"><a href="#通过反射访问特性" class="headerlink" title="通过反射访问特性"></a>通过反射访问特性</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span>[] attr = <span class="keyword">typeof</span>(Business).GetCustomAttributes(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; attr.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (attr[i] <span class="keyword">is</span> DeveloperInfoAttribute)</span><br><span class="line">        &#123;</span><br><span class="line">            DeveloperInfoAttribute developer = attr[i] <span class="keyword">as</span> DeveloperInfoAttribute;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Name:<span class="subst">&#123;developer.DeveloperName&#125;</span> Date:<span class="subst">&#123;developer.DeveloperDate&#125;</span> Describe:<span class="subst">&#123;developer.Describe&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    MethodInfo[] method = <span class="keyword">typeof</span>(Business).GetMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; method.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">object</span>[] attr = method[i].GetCustomAttributes(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; attr.Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (attr[j] <span class="keyword">is</span> DeveloperInfoAttribute)</span><br><span class="line">            &#123;</span><br><span class="line">                DeveloperInfoAttribute developer = attr[j] <span class="keyword">as</span> DeveloperInfoAttribute;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Name:<span class="subst">&#123;developer.DeveloperName&#125;</span> Date:<span class="subst">&#123;developer.DeveloperDate&#125;</span> Describe:<span class="subst">&#123;developer.Describe&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    PropertyInfo[] property = <span class="keyword">typeof</span>(Business).GetProperties();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; property.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">object</span>[] attr = property[i].GetCustomAttributes(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; attr.Length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (attr[j] <span class="keyword">is</span> DeveloperInfoAttribute)</span><br><span class="line">            &#123;</span><br><span class="line">                DeveloperInfoAttribute developer = attr[j] <span class="keyword">as</span> DeveloperInfoAttribute;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;Name:<span class="subst">&#123;developer.DeveloperName&#125;</span> Date:<span class="subst">&#123;developer.DeveloperDate&#125;</span> Describe:<span class="subst">&#123;developer.Describe&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>自定义的 <code>Attribute</code> 必须直接或者间接继承 <code>System.Attribute</code>。</li>
<li>这里有一个约定：所有自定义的特性名称都应该有个 <code>Attribute</code> 后缀。因为当你的 <code>Attribute</code> 施加到一个程序的元素上的时候，编译器先查找你的 <code>Attribute</code> 的定义，如果没有找到，那么它就会查找 特性名称 + <code>Attribute</code> 的定义。如果都没有找到，那么编译器就报错。</li>
<li><code>Attribute</code> 可以关联的元素包括：程序集(<code>assembly</code>)、模块(<code>module</code>)、类型(<code>type</code>)、属性(<code>property</code>)、事件(<code>event</code>)、字段(<code>field</code>)、方法(<code>method</code>)、参数(<code>param</code>)、返回值(<code>return</code>)。</li>
<li><code>AttributeTargets</code> 目标包括：<ul>
<li><code>All</code>：可以对任何应用程序元素应用属性；</li>
<li><code>Assembly</code>：可以对程序集应用属性；</li>
<li><code>Class</code>：可以对类应用属性；</li>
<li><code>Constructor</code>：可以对构造函数应用属性；</li>
<li><code>Delegate</code>：可以对委托应用属性；</li>
<li><code>Enum</code>：可以对枚举应用属性；</li>
<li><code>Event</code>：可以对事件应用属性；</li>
<li><code>Field</code>：可以对字段应用属性；</li>
<li><code>GenericParameter</code>：可以对泛型参数应用属性；</li>
<li><code>Interface</code>：可以对接口应用属性；</li>
<li><code>Method</code>：可以对方法应用属性；</li>
<li><code>Module</code>：<code>Module</code> 指的是可移植的可执行文件（<code>.dll</code> 或 <code>.exe</code>），而非 <code>Visual Basic</code> 标准模块；</li>
<li><code>Parameter</code>：可以对参数应用属性；</li>
<li><code>Property</code>：可以对属性 (<code>Property</code>) 应用属性 (<code>Attribute</code>)；</li>
<li><code>ReturnValue</code>：可以对返回值应用属性；</li>
<li><code>Struct</code>：可以对结构应用属性，即值类型。</li>
</ul>
</li>
<li><code>AttributeUsageAttribute</code>中的3个属性（<code>Property</code>）说明：<ul>
<li><code>ValidOn</code>：该定位参数指定可在其上放置所指示的属性 (<code>Attribute</code>) 的程序元素。<code>AttributeTargets</code> 枚举数中列出了可在其上放置属性 (<code>Attribute</code>) 的所有可能元素的集合。可通过按位“或”运算组合多个 <code>AttributeTargets</code> 值，以获取所需的有效程序元素组合。</li>
<li><code>AllowMultiple</code>：该命名参数指定能否为给定的程序元素多次指定所指示的属性。</li>
<li><code>Inherited</code>：该命名参数指定所指示的属性能否由派生类和重写成员继承。</li>
</ul>
</li>
<li><code>Attribute</code> 检测方法：<ul>
<li><code>IsDefined</code>：如果至少有一个指定的 <code>Attribute</code> 派生类的实例与目标关联，就返回 <code>true</code>。这个方法效率很高，因为他不构造（反序列化）<code>Attribute</code> 类的任何实例。</li>
<li><code>GetCustomAttributes</code>：返回一个数组，其中每个元素都是应用于目标的指定 <code>Attribute</code> 类的一个实例。</li>
<li><code>GetCustomAttributesData</code>：获取 <code>CustomAttributesData</code> 特性信息。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/attribute" data-id="cklbzl19z0006zonuddii7hc1" data-title="Attribute特性简介" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Attribute/" rel="tag">Attribute</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-regular-expression-summary" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/regular-expression-summary" class="article-date">
  <time class="dt-published" datetime="2019-04-05T11:25:00.000Z" itemprop="datePublished">2019-04-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/regular-expression-summary">正则表达式总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式作为一个强大的字符串处理方案，一直受到广大程序员的青睐。其不但使用灵活，而且字符串处理的速度也基本被各种编程语言优化到极致，在字符串匹配、提取、替换、分割等一直是首选的方案。</p>
<p>最近有一个前端妹子突然问了一个非常简单的正则表达式应该怎么写，我诧异于她不会写正则表达式的同时，思考了一下好像身边同事，真会使用正则表达式的也没有几个。</p>
<p>恰好最近在读《JavaScript面向对象编程指南》这本书的<code>RegExp</code>（JavaScript中的正则表达式对象）这一章，那就趁此机会总结一下平时工作学习中使用正则表达式的场景，同时整理一下这部分的基本知识。</p>
<blockquote>
<p>本文代码均使用 <code>C#</code> 编写，后面有空会针对不同的编程语言，介绍各自的正则表达式对象怎么使用。</p>
</blockquote>
<h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>正则我们使用最多就是校验了，也就是对一个字符串进行匹配，确认一个字符串是否符合要求，例如判断一个IP是否合法、用户名是否符合系统要求、邮箱输入合法、输入内容是否是数字等。</p>
<h3 id="从用户名校验开始"><a href="#从用户名校验开始" class="headerlink" title="从用户名校验开始"></a>从用户名校验开始</h3><p>经常能看到一些网站或系统中，设计用户名规则为：“只能使用数字或英文，并且首字母必须是字母，长度限制在6-32以内”。</p>
<p>如果没有正则表达式，代码的实现我们可能需要这么设计：循环字符串中每一个字符，判断其是否符合限制要求。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 验证用户名是否合法：6-32位字母数字组成，首字母非数字</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>用户名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>用户名是否符合系统设计规则要求<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">CheckUserName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//验证长度限制</span></span><br><span class="line">    <span class="keyword">if</span> (name.Length &lt; <span class="number">6</span> || name.Length &gt; <span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; name.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span> ch = name[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须是数字或大小写字母</span></span><br><span class="line">        <span class="keyword">if</span> (ch &lt; <span class="number">48</span> || ch &gt; <span class="number">57</span> &amp;&amp; ch &lt; <span class="number">65</span> || ch &gt; <span class="number">95</span> &amp;&amp; ch &lt; <span class="number">97</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首字母不能是数字</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ch &gt;= <span class="number">48</span> &amp;&amp; ch &lt;= <span class="number">57</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上已经尽量优化，用字符对应的编码字符来判断是否在数字或大小写字母的编码区间内，小明同学看了表示这个已经不错了，但是如果我们用正则表示呢？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 验证用户名是否合法：6-32位字母数字组成，首字母非数字</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>用户名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>用户名是否符合系统设计规则要求<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">CheckUserName</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> System.Text.RegularExpressions.Regex.IsMatch(name, <span class="string">&quot;^[a-zA-Z][a-zA-Z0-9]&#123;5,31&#125;$&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要一行代码，就可以实现上面对于用户名的校验，当然这还只是简单的用户名校验问题，如果是针对更复杂的例如IP地址/身份证/手机号码/邮箱/网址等，正则的优势还会更明显，因为这些内容我们同样可以使用一个正则表达式来实现匹配校验。</p>
<h3 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h3><p>转自：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html">最全的常用正则表达式大全——包括校验数字、字符、一些特殊的需求等等</a></p>
<h4 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h4><ol>
<li>数字：<code>^[0-9]*$</code></li>
<li>n位的数字：<code>^\d&#123;n&#125;$</code></li>
<li>至少n位的数字：<code>^\d&#123;n,&#125;$</code></li>
<li>m-n位的数字：<code>^\d&#123;m,n&#125;$</code></li>
<li>零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></li>
<li>非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>带1-2位小数的正数或负数：<code>^(\-)?\d+(\.\d&#123;1,2&#125;)?$</code></li>
<li>正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></li>
<li>有两位小数的正实数：<code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code></li>
<li>有1~3位小数的正实数：<code>^[0-9]+(.[0-9]&#123;1,3&#125;)?$</code></li>
<li>非零的正整数：<code>^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$</code></li>
<li>非零的负整数：<code>^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$</code></li>
<li>非负整数：<code>^\d+$ 或 ^[1-9]\d*|0$</code></li>
<li>非正整数：<code>^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</code></li>
<li>非负浮点数：<code>^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</code></li>
<li>非正浮点数：<code>^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</code></li>
<li>正浮点数：<code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code></li>
<li>负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code></li>
<li>浮点数：<code>^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></li>
</ol>
<h4 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h4><ol>
<li>汉字：<code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></li>
<li>英文和数字：<code>^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</code></li>
<li>长度为3-20的所有字符：<code>^.&#123;3,20&#125;$</code></li>
<li>由26个英文字母组成的字符串：<code>^[A-Za-z]+$</code></li>
<li>由26个大写英文字母组成的字符串：<code>^[A-Z]+$</code></li>
<li>由26个小写英文字母组成的字符串：<code>^[a-z]+$</code></li>
<li>由数字和26个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></li>
<li>由数字、26个英文字母或者下划线组成的字符串：<code>^\w+$ 或 ^\w&#123;3,20&#125;$</code></li>
<li>中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li>
<li>中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</code></li>
<li>可以输入含有^%&amp;’,;=?$&quot;等字符：<code>[^%&amp;&#39;,;=?$\x22]+</code></li>
<li>禁止输入含有<del>的字符：`[^</del>\x22]+`</li>
</ol>
<h4 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h4><ol>
<li>Email地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></li>
<li>域名：<code>[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</code></li>
<li>InternetURL：<code>[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li>
<li>手机号码：<code>^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\d&#123;8&#125;$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\d&#123;9&#125;$)</code></li>
<li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<code>^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</code></li>
<li>国内电话号码(0511-4405222、021-87888822)：<code>\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</code></li>
<li>18位身份证号码(数字、字母x结尾)：<code>^((\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$</code></li>
<li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<code>^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</code></li>
<li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<code>^[a-zA-Z]\w&#123;5,17&#125;$</code></li>
<li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$</code></li>
<li>日期格式：<code>^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</code></li>
<li>一年的12个月(01～09和1～12)：<code>^(0?[1-9]|1[0-2])$</code></li>
<li>一个月的31天(01～09和1～31)：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li>
<li>钱的输入格式：</li>
<li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：<code>^[1-9][0-9]*$</code></li>
<li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：<code>^(0|[1-9][0-9]*)$</code></li>
<li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<code>^(0|-?[1-9][0-9]*)$</code></li>
<li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：<code>^[0-9]+(.[0-9]+)?$</code></li>
<li>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：<code>^[0-9]+(.[0-9]&#123;2&#125;)?$</code></li>
<li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：<code>^[0-9]+(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：<code>^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：<code>^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$</code></li>
<li>xml文件：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></li>
<li>中文字符的正则表达式：<code>[\u4e00-\u9fa5]</code></li>
<li>双字节字符：<code>[^\x00-\xff]</code>    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</li>
<li>空白行的正则表达式：<code>\n\s*\r</code>    (可以用来删除空白行)</li>
<li>HTML标记的正则表达式：<code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code>    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</li>
<li>首尾空白字符的正则表达式：<code>^\s*|\s*$或(^\s*)|(\s*$)</code>    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li>
<li>腾讯QQ号：<code>[1-9][0-9]&#123;4,&#125;</code>    (腾讯QQ号从10000开始)</li>
<li>中国邮政编码：<code>[1-9]\d&#123;5&#125;(?!\d)</code>    (中国邮政编码为6位数字)</li>
<li>IP地址：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code></li>
</ol>
<p>以上是一些网上流传的正则表达式，这些内容仅供参考，如果想要确认以上正则表达式是否符合自己的使用场景，或者自己实现一个正则表达式，请看最后一个部分。</p>
<h2 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h2><p>提取顾名思义也就是从一段字符串，获取我们需要的特定内容，例如在网页爬虫中，我们常常需要获取html中的文本内容，或特定标签下的内容。（当然我们可以使用<code>XPath</code>语法进行解析，但是正则也不失为一个优秀的解决方案，而且很多XPath方案的底层是基于正则实现的。后面介绍爬虫的时候，再具体介绍XPath。）</p>
<p>如果内容是我们需要提取的内容，我们可以使用<code>(</code> <code>)</code>将需要提取的内容包起来，这样正则匹配时会将这部分内容提取到集合中，我们可以从集合中获取这些元素。</p>
<h3 id="提取邮箱中的用户名"><a href="#提取邮箱中的用户名" class="headerlink" title="提取邮箱中的用户名"></a>提取邮箱中的用户名</h3><p>C# 中，提取到的内容在Group集合中，集合中第一个元素为匹配的所有内容，例如下面代码第一个元素是匹配到的邮箱，而后的元素才是我们使用小括号提取的内容。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 验证邮箱并提取邮箱中的用户名</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;email&quot;&gt;</span>邮箱<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>用户名<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>邮箱内容是否合法<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">CheckEmail</span>(<span class="params"><span class="built_in">string</span> email, <span class="keyword">out</span> <span class="built_in">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    name = <span class="literal">null</span>;</span><br><span class="line">    System.Text.RegularExpressions.Match match </span><br><span class="line">        = System.Text.RegularExpressions.Regex.Match(email, <span class="string">@&quot;^(\w+([-+.]\w+)*)@\w+([-.]\w+)*\.\w+([-.]\w+)*$&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match.Success)</span><br><span class="line">    &#123;</span><br><span class="line">        name = match.Groups[<span class="number">1</span>].Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> match.Success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单测试：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> email = <span class="string">&quot;hd2y@outlook.com&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (CheckEmail(email, <span class="keyword">out</span> <span class="built_in">string</span> name))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;用户<span class="subst">&#123;name&#125;</span>邮箱验证合法：<span class="subst">&#123;email&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="提取Html内容中所有标题"><a href="#提取Html内容中所有标题" class="headerlink" title="提取Html内容中所有标题"></a>提取Html内容中所有标题</h3><p>在邮箱匹配的例子中我们对内容进行了限定，<code>^</code>代表匹配开头，<code>$</code>代表匹配结尾，所以其实际上是对整个内容进行匹配。</p>
<p>但是我们可能会碰到对内容进行多次匹配的情况，例如提取html内容中所有的标题也就是h1-h6标签，这就是一个循环匹配的过程，所以我们不能限定开始于结束。</p>
<p>另外一个标签有标签名、属性、内容，当让我们可以使用上文的方式，在匹配到的内容通过索引去获取内容，但是正则也允许我们使用别名，所以以下的例子中，我们将为其取别名，然后通过别名来获取内容。同时我们还可以使用别名配合<code>\k</code>(命名向后引用)来确定一个标签的闭合。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;Title&gt; <span class="title">FetchTitle</span>(<span class="params"><span class="built_in">string</span> title</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (System.Text.RegularExpressions.Match item</span><br><span class="line">        <span class="keyword">in</span> System.Text.RegularExpressions.Regex.Matches(title, <span class="string">@&quot;&lt;(?&#x27;TN&#x27;H[1-6])\s*(?&#x27;TP&#x27;[^&lt;&gt;]*)&gt;(?&#x27;TC&#x27;.*?)&lt;/\k&#x27;TN&#x27;&gt;&quot;</span></span><br><span class="line">           , System.Text.RegularExpressions.RegexOptions.IgnoreCase))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">Title</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Name = item.Groups[<span class="string">&quot;TN&quot;</span>].Value,</span><br><span class="line">            Property = item.Groups[<span class="string">&quot;TP&quot;</span>].Value,</span><br><span class="line">            Content = item.Groups[<span class="string">&quot;TC&quot;</span>].Value</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Title</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Property &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单测试：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> html = <span class="string">&quot;&lt;h1&gt;h1&lt;/h1&gt;&lt;h2&gt;h2&lt;/h2&gt;&lt;h3&gt;h3&lt;/h3&gt;&lt;h4&gt;h4&lt;/h4&gt;&lt;h5 style=\&quot;color:red;\&quot;&gt;h5&lt;/h5&gt;&lt;h6&gt;h6&lt;/h6&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="function">Title title <span class="keyword">in</span> <span class="title">FetchTitle</span>(<span class="params">html</span>))</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;获取到标题<span class="subst">&#123;title.Name&#125;</span> 内容：<span class="subst">&#123;title.Content&#125;</span> 属性：<span class="subst">&#123;title.Property&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上匹配部分写法并不严格，例如标题标签嵌套其他标签内容时可能存在问题，这里只是简单举例，不考虑复杂正则表达式写法。</p>
</blockquote>
<blockquote>
<p>Html内容提取可以参考 <a target="_blank" rel="noopener" href="https://github.com/Anduin2017/HSharp">Aiursoft.HSharp</a> 项目，里面对于Html的解析较为标准可用。</p>
</blockquote>
<h2 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h2><p>对于字符串操作，大部分编程语言都提供了Split方法，同样的正则也有类似的方法，但是正则分割适用范围更广，适合在分隔符不确定但是有一定规律的情况下使用。</p>
<h3 id="分割时间信息"><a href="#分割时间信息" class="headerlink" title="分割时间信息"></a>分割时间信息</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] dateInfo = Regex.Split(<span class="string">&quot;2019-04-01 00:00:00&quot;</span>, <span class="string">@&quot;\W&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="提取Pascal方法名中的单词"><a href="#提取Pascal方法名中的单词" class="headerlink" title="提取Pascal方法名中的单词"></a>提取Pascal方法名中的单词</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] words = Regex.Split(<span class="string">&quot;ILoveYou&quot;</span>, <span class="string">&quot;(?!^)(?=[A-Z])&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>(?!...)</code> 正向否定预查；<code>(?=...)</code> 正向肯定预查。</p>
</blockquote>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>在我的日常工作中，正则使用频率一般是 匹配 &gt; 提取 &gt; 替换 &gt; 分割，替换在一些特定环境下，真的是让人有种相见恨晚的感觉。</p>
<h3 id="处理ASTM协议消息"><a href="#处理ASTM协议消息" class="headerlink" title="处理ASTM协议消息"></a>处理ASTM协议消息</h3><p>在工作中有时会和其他系统和设备打交道，做一些接口，他们都有自己定义的通讯协议，而ASTM就是其中一种。</p>
<p>刚开始处理这个协议的一个问题就在于，这个协议会将完整的消息分块，然后加入校验字符，类似下面这种结果：（以下内容仅仅是简单举例，验证内容未经实际计算，ASTM协议更多解释可以搜索相关文档了解）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;STX&gt;1AAA&lt;ETB&gt;1F&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">&lt;STX&gt;2BBB&lt;ETB&gt;2E&lt;CR&gt;&lt;LF&gt;</span><br><span class="line">&lt;STX&gt;3CCC&lt;ETX&gt;3D&lt;CR&gt;&lt;LF&gt;</span><br></pre></td></tr></table></figure>
<p>其中我们需要的只是其中的AAABBBCCC，但是其为了确认消息的完整性加入了一些消息块标识和校验码，这些不是我们需要的但是使用字符串自带的Replace或者Split取消息部分就比较麻烦，至少需要写一个循环。</p>
<p>而正则就相对简单的多：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> content = <span class="string">&quot;&quot;</span>;<span class="comment">//内容略</span></span><br><span class="line">content = Regex.Replace(content, <span class="string">@&quot;(\u0002[0-7]&#123;1&#125;)|((\u0003|\u0017)[0-9A-F]&#123;2&#125;\r\n)&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="删除重复单词"><a href="#删除重复单词" class="headerlink" title="删除重复单词"></a>删除重复单词</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> content = <span class="string">&quot;I love you very very very much.&quot;</span>;<span class="comment">//内容略</span></span><br><span class="line">content = Regex.Replace(content, <span class="string">@&quot;(?&lt;word&gt;[a-zA-Z]+)( \k&lt;word&gt;)+&quot;</span>, <span class="string">&quot;$&#123;word&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>以上只是一些使用场景的简单举例，以下部分时摘抄自菜鸟教程关于正则表达式部分的文档，供学习或者查阅时使用。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p>
<p>例如：</p>
<ul>
<li><code>runoo+b</code>，可以匹配 runoob、runooob、runoooooob 等，<code>+</code> 号代表前面的字符必须至少出现一次（1次或多次）。</li>
<li><code>runoo*b</code>，可以匹配 runob、runoob、runoooooob 等，<code>*</code> 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。</li>
<li><code>colou?r</code> 可以匹配 color 或者 colour，<code>?</code> 问号代表前面的字符最多只可以出现一次（0次、或1次）。</li>
</ul>
<p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p>
<p>正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为”元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。</p>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\cx</td>
<td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code>。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <code>runoo*b</code> 中的 <code>*</code>，简单的说就是表示任何字符串的意思。如果要查找字符串中的 <code>*</code> 符号，则需要对 <code>*</code> 进行转义，即在其前加一个 <code>\</code>: <code>runo\*ob</code> 匹配 <code>runo*ob</code>。</p>
<p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：</p>
<table>
<thead>
<tr>
<th align="left">特别字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$</td>
<td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td>
</tr>
<tr>
<td align="left">( )</td>
<td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。要匹配 <code>*</code> 字符，请使用 <code>\*</code>。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td align="left">.</td>
<td align="left">匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td align="left"><code>[</code></td>
<td align="left">标记一个中括号表达式的开始。要匹配 <code>[</code>，请使用 <code>\[</code>。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。</td>
</tr>
<tr>
<td align="left">{</td>
<td align="left">标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <code>*</code> 或 <code>+</code> 或 <code>?</code> 或 <code>&#123;n&#125;</code> 或 <code>&#123;n,&#125;</code> 或 <code>&#123;n,m&#125;</code> 共6种。</p>
<p>正则表达式的限定符有：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">*</td>
<td align="left">匹配前面的子表达式零次或多次。例如，<code>zo*</code> 能匹配 “z” 以及 “zoo”。<code>*</code> 等价于{0,}。</td>
</tr>
<tr>
<td align="left">+</td>
<td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>
</tr>
<tr>
<td align="left">?</td>
<td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td>
</tr>
<tr>
<td align="left">{n}</td>
<td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>
</tr>
<tr>
<td align="left">{n,}</td>
<td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>
</tr>
<tr>
<td align="left">{n,m}</td>
<td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>
</tr>
</tbody></table>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">\</td>
<td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td>
</tr>
<tr>
<td align="left">^</td>
<td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td>
</tr>
</tbody></table>
<ul>
<li><pre><code>     |匹配前面的子表达式零次或多次。例如，`zo*` 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。`*` 等价于&#123;0,&#125;。
</code></pre>
</li>
</ul>
<ul>
<li><pre><code>     |匹配前面的子表达式一次或多次。例如，&#39;zo+&#39; 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 &#123;1,&#125;。
</code></pre>
?          |匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。<br>{n}        |n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。<br>{n,}       |n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 <code>&#39;o*&#39;</code>。<br>{n,m}      |m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。<br>?          |当该字符紧跟在任何一个其他限制符 (<code>*</code>, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。<br>.          |匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(.|\n)”的模式。<br>(pattern)  |匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。<br>(?:pattern)|匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。<br>(?=pattern)|正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<br>(?!pattern)|正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。<br>(?&lt;=pattern)|反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;=95|98|NT|2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows”。<br>(?&lt;!pattern)|反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95|98|NT|2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。<br>x|y        |匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。<br><code>[xyz]</code>      |字符集合。匹配所包含的任意一个字符。例如， <code>&#39;[abc]&#39;</code> 可以匹配 “plain” 中的 ‘a’。<br><code>[^xyz]</code>     |负值字符集合。匹配未包含的任意字符。例如， <code>&#39;[^abc]&#39;</code> 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。<br><code>[a-z]</code>      |字符范围。匹配指定范围内的任意字符。例如，<code>&#39;[a-z]&#39;</code> 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。<br><code>[^a-z]</code>     |负值字符范围。匹配任何不在指定范围内的任意字符。例如，<code>&#39;[^a-z]&#39;</code> 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。<br>\b         |匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。<br>\B         |匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。<br>\cx        |匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。<br>\d         |匹配一个数字字符。等价于 <code>[0-9]</code>。<br>\D         |匹配一个非数字字符。等价于 <code>[^0-9]</code>。<br>\f         |匹配一个换页符。等价于 \x0c 和 \cL。<br>\n         |匹配一个换行符。等价于 \x0a 和 \cJ。<br>\r         |匹配一个回车符。等价于 \x0d 和 \cM。<br>\s         |匹配任何空白字符，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code>。<br>\S         |匹配任何非空白字符。等价于 <code>[^ \f\n\r\t\v]</code>。<br>\t         |匹配一个制表符。等价于 \x09 和 \cI。<br>\v         |匹配一个垂直制表符。等价于 \x0b 和 \cK。<br>\w         |匹配字母、数字、下划线。等价于<code>&#39;[A-Za-z0-9_]&#39;</code>。<br>\W         |匹配非字母、数字、下划线。等价于 <code>&#39;[^A-Za-z0-9_]&#39;</code>。<br>\xn        |匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。<br>\num       |匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。<br>\n         |标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。<br>\nm        | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。<br>\nml       |如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。<br>\un        |匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/regular-expression-summary" data-id="cklbzl1es00cnzonucgim8irs" data-title="正则表达式总结" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AD%A3%E5%88%99/" rel="tag">正则</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-security-helper" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/security-helper" class="article-date">
  <time class="dt-published" datetime="2019-04-03T13:11:00.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/security-helper">SecurityHelper 加密解密帮助类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="SecurityHelper-帮助类"><a href="#SecurityHelper-帮助类" class="headerlink" title="SecurityHelper 帮助类"></a><code>SecurityHelper</code> 帮助类</h2><p>该帮助类主要实现了 <code>MD5</code> 算法的 <code>加密</code>，<code>DES</code>、<code>3DES</code>、<code>RSA</code> 算法的 <code>加密</code> 与 <code>解密</code>，内部简单实现了一个混淆算法。</p>
<h2 id="MD5-加密算法"><a href="#MD5-加密算法" class="headerlink" title="MD5 加密算法"></a><code>MD5</code> 加密算法</h2><p><code>MD5</code> 消息摘要算法：全称是 <code>Message-Digest Algorithm</code>，一种被广泛使用的密码散列函数，可以产生出一个 <code>128位</code>（<code>16字节</code>）的 <code>散列值</code>（<code>hash value</code>），用于确保信息传输完整一致。。</p>
<p>MD5主要用途：</p>
<ul>
<li>对一段信息生成信息摘要，该摘要对该信息具有唯一性，可以作为数字签名</li>
<li>用于验证文件的有效性(是否有丢失或损坏的数据)</li>
<li>对用户密码的加密</li>
<li>在哈希函数中计算散列值</li>
</ul>
<p>从上边的主要用途中我们看到，由于算法的某些不可逆特征，在加密应用上有较好的安全性。通过使用 <code>MD5</code> 加密算法，我们输入一个任意长度的字节串，都会生成一个<code>128位</code> 的整数。所以根据这一点 <code>MD5</code> 被广泛的用作密码加密。</p>
<p><code>SecurityHelper</code> 中调用的方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = SecurityHelper.EncryptByMD5(<span class="string">&quot;测试&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="DES-与-3DES-加密算法"><a href="#DES-与-3DES-加密算法" class="headerlink" title="DES 与 3DES 加密算法"></a><code>DES</code> 与 <code>3DES</code> 加密算法</h2><p><code>DES</code> 全称为 <code>Data Encryption Standard</code>，即数据加密标准，是一种使用密钥加密的块算法。<code>DES</code> 算法的入口参数有三个：<code>Key</code>、<code>Data</code>、<code>Mode</code>。其中 <code>Key</code> 为 <code>7个字节</code> 共 <code>56位</code>，是 <code>DES算法</code> 的工作密钥；<code>Data</code> 为 <code>8个字节</code> <code>64位</code>，是要被加密或被解密的数据；<code>Mode</code> 为 <code>DES</code> 的工作方式，有两种：加密或解密。其速度较快，适用于加密大量数据的场合。</p>
<p><code>SecurityHelper</code> 中调用的方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> encryptStr = SecurityHelper.EncryptByDES(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> str = SecurityHelper.DecryptByDES(encryptStr);</span><br></pre></td></tr></table></figure>
<p><code>3DES</code>（即 <code>Triple DES</code>）是 <code>DES</code> 向 <code>AES</code> 过渡的加密算法，它使用 <code>3条</code> <code>56位</code> 的密钥对数据进行 <code>三次加密</code>。是 <code>DES</code> 的一个更安全的变形。它以 <code>DES</code> 为基本模块，通过组合分组方法设计出分组加密算法。比起最初的 <code>DES</code>，<code>3DES</code> 更为安全。</p>
<p><code>SecurityHelper</code> 中调用的方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> encryptStr = SecurityHelper.EncryptByTDES(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> str = SecurityHelper.DecryptByTDES(encryptStr);</span><br></pre></td></tr></table></figure>
<h2 id="RSA-加密算法"><a href="#RSA-加密算法" class="headerlink" title="RSA 加密算法"></a><code>RSA</code> 加密算法</h2><p><code>RSA</code> 加密算法是一种 <code>非对称</code> 加密算法。在公开密钥加密和电子商业中 <code>RSA</code> 被广泛使用。</p>
<p><code>RSA</code> 算法是第一个能同时用于加密和数字签名的算法，也易于理解和操作。<code>RSA</code> 是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，截止 <code>2017年</code> 被普遍认为是最优秀的公钥方案之一。</p>
<p><code>SecurityHelper</code> 中调用的方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成公钥与私钥</span></span><br><span class="line"><span class="keyword">var</span> kv = SecurityHelper.GeneralRSAKeys();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> encryptStr = SecurityHelper.EncryptByRSAFromXmlString(<span class="string">&quot;测试&quot;</span>, kv.Key);</span><br><span class="line"><span class="built_in">string</span> str = SecurityHelper.DecryptByRSAFromXmlString(encryptStr, kv.Value);</span><br></pre></td></tr></table></figure>
<h2 id="混淆-与-反混淆"><a href="#混淆-与-反混淆" class="headerlink" title="混淆 与 反混淆"></a><code>混淆</code> 与 <code>反混淆</code></h2><p>当需求对数据的传输有不高的安全加密，且加密的时间复杂度越低越好，这时我们可以使用简单的混淆算法，<code>SecurityHelper</code> 实现了一个简单的混淆算法供开发人员调用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> encryptStr = SecurityHelper.MixUp(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> str = SecurityHelper.ClearUp(encryptStr);</span><br></pre></td></tr></table></figure>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Security.Cryptography;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">System</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 加密安全帮助类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SecurityHelper</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> MD5加密字符串 (不可逆)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>需要加密的内容<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>加密密钥，防止简单密码被破解<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryStyle&quot;&gt;</span>加密后结果内容样式。true:HEX格式加密结果，含“-”;Base64格式加密结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>加密结果<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">EncryptByMD5</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> key = <span class="literal">default</span>(<span class="built_in">string</span></span>), <span class="built_in">bool</span> binaryStyle</span> = <span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MD5 md5 = MD5.Create();</span><br><span class="line">            <span class="built_in">byte</span>[] bytes = md5.ComputeHash(Encoding.UTF8.GetBytes(text + key));</span><br><span class="line">            <span class="keyword">return</span> binaryStyle ? BitConverter.ToString(bytes) : Convert.ToBase64String(bytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> DES加密字符串 (可逆)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>待加密的字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>DES加密的私钥，必须是字节长度8位的字符串，否则会补0。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;iv&quot;&gt;</span>DES加密偏移量，必须是&gt;=8位长的字符串，否则会补0。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryStyle&quot;&gt;</span>加密后结果内容样式。true:HEX格式加密结果，含“-”;Base64格式加密结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>加密后的字符串<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">EncryptByDES</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> key = <span class="string">&quot;&quot;</span>, <span class="built_in">string</span> iv = <span class="string">&quot;&quot;</span>, <span class="built_in">bool</span> binaryStyle = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;<span class="built_in">byte</span>&gt; bKey = Encoding.UTF8.GetBytes(key).ToList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = bKey.Count; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bKey.Add((<span class="built_in">byte</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            bKey = bKey.GetRange(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">            List&lt;<span class="built_in">byte</span>&gt; bIV = Encoding.UTF8.GetBytes(iv).ToList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = bIV.Count; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bIV.Add((<span class="built_in">byte</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">using</span> (DESCryptoServiceProvider des = <span class="keyword">new</span> DESCryptoServiceProvider())</span><br><span class="line">            <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] inData = Encoding.UTF8.GetBytes(text);</span><br><span class="line">                <span class="keyword">using</span> (CryptoStream cs = <span class="keyword">new</span> CryptoStream(ms, des.CreateEncryptor(bKey.ToArray(), bIV.ToArray()), CryptoStreamMode.Write))</span><br><span class="line">                &#123;</span><br><span class="line">                    cs.Write(inData, <span class="number">0</span>, inData.Length);</span><br><span class="line">                    cs.FlushFinalBlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> binaryStyle ? BitConverter.ToString(ms.ToArray()) : Convert.ToBase64String(ms.ToArray());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> DES解密字符串</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>待解密的字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>DES加密的私钥，必须是字节长度8位的字符串，否则会补0。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;iv&quot;&gt;</span>DES加密偏移量，必须是&gt;=8位长的字符串，否则会补0。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryStyle&quot;&gt;</span>解密内容样式。true:HEX格式加密结果，含“-”;Base64格式加密结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>解密后的字符串<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DecryptByDES</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> key = <span class="string">&quot;&quot;</span>, <span class="built_in">string</span> iv = <span class="string">&quot;&quot;</span>, <span class="built_in">bool</span> binaryStyle = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;<span class="built_in">byte</span>&gt; bKey = Encoding.UTF8.GetBytes(key).ToList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = bKey.Count; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bKey.Add((<span class="built_in">byte</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            bKey = bKey.GetRange(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">            List&lt;<span class="built_in">byte</span>&gt; bIV = Encoding.UTF8.GetBytes(iv).ToList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = bIV.Count; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bIV.Add((<span class="built_in">byte</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">using</span> (DESCryptoServiceProvider des = <span class="keyword">new</span> DESCryptoServiceProvider())</span><br><span class="line">            <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] inData = binaryStyle ? text.GetBytesFromBitConverter() : Convert.FromBase64String(text);</span><br><span class="line">                <span class="keyword">using</span> (CryptoStream cs = <span class="keyword">new</span> CryptoStream(ms, des.CreateDecryptor(bKey.ToArray(), bIV.ToArray()), CryptoStreamMode.Write))</span><br><span class="line">                &#123;</span><br><span class="line">                    cs.Write(inData, <span class="number">0</span>, inData.Length);</span><br><span class="line">                    cs.FlushFinalBlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Encoding.UTF8.GetString(ms.ToArray());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> TDES加密字符串 (可逆)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>待加密的字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>TDES加密的私钥，必须是字节长度24位的字符串，否则会自动补位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;iv&quot;&gt;</span>TDES加密偏移量，必须是字节长度&gt;=8位的字符串，否则会自动补位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryStyle&quot;&gt;</span>加密后结果内容样式。true:HEX格式加密结果，含“-”;Base64格式加密结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>加密后的字符串<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">EncryptByTDES</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> key = <span class="string">&quot;&quot;</span>, <span class="built_in">string</span> iv = <span class="string">&quot;&quot;</span>, <span class="built_in">bool</span> binaryStyle = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;<span class="built_in">byte</span>&gt; bKey = Encoding.UTF8.GetBytes(key).ToList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = bKey.Count; i &lt; <span class="number">24</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bKey.Add((<span class="built_in">byte</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            bKey = bKey.GetRange(<span class="number">0</span>, <span class="number">24</span>);</span><br><span class="line">            List&lt;<span class="built_in">byte</span>&gt; bIV = Encoding.UTF8.GetBytes(iv).ToList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = bIV.Count; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bIV.Add((<span class="built_in">byte</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">using</span> (TripleDESCryptoServiceProvider des = <span class="keyword">new</span> TripleDESCryptoServiceProvider())</span><br><span class="line">            <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] inData = Encoding.UTF8.GetBytes(text);</span><br><span class="line">                <span class="keyword">using</span> (CryptoStream cs = <span class="keyword">new</span> CryptoStream(ms, des.CreateEncryptor(bKey.ToArray(), bIV.ToArray()), CryptoStreamMode.Write))</span><br><span class="line">                &#123;</span><br><span class="line">                    cs.Write(inData, <span class="number">0</span>, inData.Length);</span><br><span class="line">                    cs.FlushFinalBlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> binaryStyle ? BitConverter.ToString(ms.ToArray()) : Convert.ToBase64String(ms.ToArray());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> TDES解密字符串</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>待解密的字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;key&quot;&gt;</span>TDES加密的私钥，必须是字节长度24位的字符串，否则会自动补位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;iv&quot;&gt;</span>TDES加密偏移量，必须是字节长度&gt;=8位的字符串，否则会自动补位。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryStyle&quot;&gt;</span>解密内容样式。true:HEX格式加密结果，含“-”;Base64格式加密结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>解密后的字符串<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DecryptByTDES</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> key = <span class="string">&quot;&quot;</span>, <span class="built_in">string</span> iv = <span class="string">&quot;&quot;</span>, <span class="built_in">bool</span> binaryStyle = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            List&lt;<span class="built_in">byte</span>&gt; bKey = Encoding.UTF8.GetBytes(key).ToList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = bKey.Count; i &lt; <span class="number">24</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bKey.Add((<span class="built_in">byte</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            bKey = bKey.GetRange(<span class="number">0</span>, <span class="number">24</span>);</span><br><span class="line">            List&lt;<span class="built_in">byte</span>&gt; bIV = Encoding.UTF8.GetBytes(iv).ToList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = bIV.Count; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                bIV.Add((<span class="built_in">byte</span>)i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">using</span> (TripleDESCryptoServiceProvider des = <span class="keyword">new</span> TripleDESCryptoServiceProvider())</span><br><span class="line">            <span class="keyword">using</span> (MemoryStream ms = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] inData = binaryStyle ? text.GetBytesFromBitConverter() : Convert.FromBase64String(text);</span><br><span class="line">                <span class="keyword">using</span> (CryptoStream cs = <span class="keyword">new</span> CryptoStream(ms, des.CreateDecryptor(bKey.ToArray(), bIV.ToArray()), CryptoStreamMode.Write))</span><br><span class="line">                &#123;</span><br><span class="line">                    cs.Write(inData, <span class="number">0</span>, inData.Length);</span><br><span class="line">                    cs.FlushFinalBlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> Encoding.UTF8.GetString(ms.ToArray());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取RSA加密公钥和私钥</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>key:公钥 value:公钥和私钥<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; <span class="title">GeneralRSAKeys</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">using</span> (RSACryptoServiceProvider rsa = <span class="keyword">new</span> RSACryptoServiceProvider())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;(rsa.ToXmlString(<span class="literal">false</span>), rsa.ToXmlString(<span class="literal">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> RSA加密字符串 (可逆)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>待加密的字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>密钥容器的名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryStyle&quot;&gt;</span>加密后结果内容样式。true:HEX格式加密结果，含“-”;Base64格式加密结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>加密后的字符串<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">EncryptByRSA</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> name, <span class="built_in">bool</span> binaryStyle = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CspParameters param = <span class="keyword">new</span> CspParameters() &#123; KeyContainerName = name &#125;;</span><br><span class="line">            <span class="keyword">using</span> (RSACryptoServiceProvider rsa = <span class="keyword">new</span> RSACryptoServiceProvider(param))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] plaindata = Encoding.UTF8.GetBytes(text);</span><br><span class="line">                <span class="built_in">byte</span>[] encryptdata = rsa.Encrypt(plaindata, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span> binaryStyle ? BitConverter.ToString(encryptdata) : Convert.ToBase64String(encryptdata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> RSA解密字符串</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>待解密的字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;name&quot;&gt;</span>密钥容器的名称。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryStyle&quot;&gt;</span>解密内容样式。true:HEX格式加密结果，含“-”;Base64格式加密结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>解密后的字符串<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DecryptByRSA</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> name, <span class="built_in">bool</span> binaryStyle = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            CspParameters param = <span class="keyword">new</span> CspParameters() &#123; KeyContainerName = name &#125;;</span><br><span class="line">            <span class="keyword">using</span> (RSACryptoServiceProvider rsa = <span class="keyword">new</span> RSACryptoServiceProvider(param))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>[] encryptdata = binaryStyle ? text.GetBytesFromBitConverter() : Convert.FromBase64String(text);</span><br><span class="line">                <span class="built_in">byte</span>[] decryptdata = rsa.Decrypt(encryptdata, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span> Encoding.UTF8.GetString(decryptdata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> RSA加密字符串 (可逆)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>待加密的字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;xml&quot;&gt;</span>含有密钥信息的xml字符串。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryStyle&quot;&gt;</span>加密后结果内容样式。true:HEX格式加密结果，含“-”;Base64格式加密结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>加密后的字符串<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">EncryptByRSAFromXmlString</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> xml, <span class="built_in">bool</span> binaryStyle = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">using</span> (RSACryptoServiceProvider rsa = <span class="keyword">new</span> RSACryptoServiceProvider())</span><br><span class="line">            &#123;</span><br><span class="line">                rsa.FromXmlString(xml);</span><br><span class="line">                <span class="built_in">byte</span>[] plaindata = Encoding.UTF8.GetBytes(text);</span><br><span class="line">                <span class="built_in">byte</span>[] encryptdata = rsa.Encrypt(plaindata, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span> binaryStyle ? BitConverter.ToString(encryptdata) : Convert.ToBase64String(encryptdata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> RSA解密字符串</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>待解密的字符串<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;xml&quot;&gt;</span>含有密钥信息的xml字符串。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;binaryStyle&quot;&gt;</span>解密内容样式。true:HEX格式加密结果，含“-”;Base64格式加密结果。<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>解密后的字符串<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">DecryptByRSAFromXmlString</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">string</span> xml, <span class="built_in">bool</span> binaryStyle = <span class="literal">true</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">using</span> (RSACryptoServiceProvider rsa = <span class="keyword">new</span> RSACryptoServiceProvider())</span><br><span class="line">            &#123;</span><br><span class="line">                rsa.FromXmlString(xml);</span><br><span class="line">                <span class="built_in">byte</span>[] encryptdata = binaryStyle ? text.GetBytesFromBitConverter() : Convert.FromBase64String(text);</span><br><span class="line">                <span class="built_in">byte</span>[] decryptdata = rsa.Decrypt(encryptdata, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">return</span> Encoding.UTF8.GetString(decryptdata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 用时间简单混淆</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>原始文本<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;timestampLength&quot;&gt;</span>混淆用时间戳长度<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>混淆后文本<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">MixUp</span>(<span class="params"><span class="built_in">string</span> text,<span class="built_in">int</span> timestampLength = <span class="number">36</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> timestamp = Guid.NewGuid().ToString();</span><br><span class="line">            <span class="keyword">var</span> count = text.Length + timestampLength;</span><br><span class="line">            <span class="keyword">var</span> sbd = <span class="keyword">new</span> StringBuilder(count);</span><br><span class="line">            <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; timestampLength &amp;&amp; k &lt; text.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sbd.Append(text[k]);</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        sbd.Append(timestamp[j]);</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= timestampLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    sbd.Append(text[k]);</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (k &gt;= text.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sbd.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 简单反混淆</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;text&quot;&gt;</span>需要执行反混淆的文本<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;timestampLength&quot;&gt;</span>混淆用时间戳长度<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>原始文本<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ClearUp</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">int</span> timestampLength = <span class="number">36</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> sbd = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="built_in">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; text.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sbd.Append(text[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j &gt; timestampLength)</span><br><span class="line">                &#123;</span><br><span class="line">                    sbd.Append(text.Substring(i));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> sbd.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 刚刚发现部分代码调用了我自己封装的一个扩展方法的文件，主要是字符串与二进制流转换的处理，可以根据方法名含义自行调整对应方法，后面我也会将这部分代码上传上来，这里就偷个懒不做修改了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/security-helper" data-id="cklbzl1et00cqzonu9jfv2hot" data-title="SecurityHelper 加密解密帮助类" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A0%E5%AF%86/" rel="tag">加密</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-create-a-class-library-project-that-supports-multiple-dotnet-versions" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/create-a-class-library-project-that-supports-multiple-dotnet-versions" class="article-date">
  <time class="dt-published" datetime="2019-04-03T12:55:00.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/create-a-class-library-project-that-supports-multiple-dotnet-versions">创建支持多个dotnet版本的类库项目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="如何创建支持支持多个-dotnet-版本的类库项目"><a href="#如何创建支持支持多个-dotnet-版本的类库项目" class="headerlink" title="如何创建支持支持多个 dotnet 版本的类库项目"></a>如何创建支持支持多个 <code>dotnet</code> 版本的类库项目</h2><p>开发中，经常会遇到需要所开发的类库同时支持 <code>net40</code> 、 <code>net451</code> 、 <code>netstandart2.0</code> 等版本。</p>
<p>随意打开一些常用的开源项目比如“Dapper”就会发现，项目并不会针对不同的 <code>dotnet</code> 版本，创建不同分支，而是一套代码支持了多个不同的 <code>dotnet</code> 版本。</p>
<p>而针对不同版本的语言特性，只需要使用 <code>#if</code> 预处理指令进行处理即可，可以节约了我们的开发成本，方便我们统一的管理项目源码。</p>
<p>以下部分的内容是基于 Visual Studio 2017 进行的实践，建议安装最新的VS版本。</p>
<h3 id="项目文件-csproj"><a href="#项目文件-csproj" class="headerlink" title="项目文件 *.csproj"></a>项目文件 <code>*.csproj</code></h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p><strong>注意：</strong>创建的项目类型必须是 <code>.NET Standard</code> 。</p>
<p><img src="/upload/2019/3/2019021914395620190403205200764.png"></p>
<h4 id="编辑-csproj-文件"><a href="#编辑-csproj-文件" class="headerlink" title="编辑 *.csproj 文件"></a>编辑 <code>*.csproj</code> 文件</h4><p>在项目上右键，右键菜单中便有 <code>编辑 *.csproj</code> 的选项：</p>
<p><img src="/upload/2019/3/2019021914453220190403205158717.png"></p>
<p>如果是新建的 <code>类库(.NET Standard)</code> 项目，<code>*.csproj</code> 文件内容大概是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>netstandard2.0<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>正常一个扩展后的内容是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageId</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">PackageId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageTags</span>&gt;</span>test1;test2<span class="tag">&lt;/<span class="name">PackageTags</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Authors</span>&gt;</span>John Sun<span class="tag">&lt;/<span class="name">Authors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFrameworks</span>&gt;</span>net40;net451;netstandard2.0<span class="tag">&lt;/<span class="name">TargetFrameworks</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Jint&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;2.11.58&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Newtonsoft.Json&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;12.0.1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;NLog&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;4.5.11&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;NLog.Config&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;4.5.11&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;NPOI&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;2.4.1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(TargetFramework)&#x27; == &#x27;net40&#x27; OR &#x27;$(TargetFramework)&#x27; == &#x27;net451&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Data&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Web&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Xml&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;System.Xml.Linq&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Reference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.CSharp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;dapper_net40&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span> <span class="attr">Condition</span>=<span class="string">&quot;&#x27;$(TargetFramework)&#x27; == &#x27;netstandard2.0&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.CSharp&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;4.5.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;dapper_net40&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;1.0.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ProjectReference</span> <span class="attr">Include</span>=<span class="string">&quot;..\..\src\Test\TestCore.csproj&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="需要关注的配置节点"><a href="#需要关注的配置节点" class="headerlink" title="需要关注的配置节点"></a>需要关注的配置节点</h4><ul>
<li><code>PropertyGroup</code>: 配置项目的基本信息<ul>
<li><code>TargetFrameworks</code>: 配置项目对框架元包的引用，注意默认一个引用时是 <code>TargetFramework</code>，需要修改为复数</li>
<li><code>PackageId</code>: 指定生成包的名称</li>
<li><code>PackageTags</code>: 标记</li>
<li><code>PackageVersion</code>: 指定生成的包所具有的版本</li>
<li><code>Authors</code>: 以分号分隔的包作者列表</li>
<li><code>OutputType</code>: 可以使用 <code>&lt;OutputType&gt;Exe&lt;/OutputType&gt;</code> 指定项目为控制台项目</li>
<li>……</li>
</ul>
</li>
<li><code>ItemGroup</code>: 向项目添加依赖项<ul>
<li><code>PackageReference</code>: nuget程序包</li>
<li><code>Reference</code>: 程序集引用</li>
<li><code>ProjectReference</code>: 项目引用</li>
</ul>
</li>
</ul>
<h3 id="C-预处理器指令"><a href="#C-预处理器指令" class="headerlink" title="C# 预处理器指令"></a><code>C#</code> 预处理器指令</h3><p>我们在开发中可能会遇到部分代码在不同的 <code>dotnet</code> 版本上有不同的实现，或者部分程序类型/方法等只能在指定的 <code>dotnet</code> 版本上使用，这个时候我们就可以使用 <code>C#</code> 的预处理指令 <code>#if</code> 。</p>
<h4 id="针对不同的目标框架使用最新的-API"><a href="#针对不同的目标框架使用最新的-API" class="headerlink" title="针对不同的目标框架使用最新的 API:"></a>针对不同的目标框架使用最新的 API:</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> NET40</span></span><br><span class="line">        WebClient _client = <span class="keyword">new</span> WebClient();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        HttpClient _client = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在目标框架下屏蔽一个方法"><a href="#在目标框架下屏蔽一个方法" class="headerlink" title="在目标框架下屏蔽一个方法"></a>在目标框架下屏蔽一个方法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !NET20</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">OpenAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/tools/csproj">.NET Core 的 csproj 格式的新增内容</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/core/tools/dependencies">使用 .NET Core SDK 1.0 管理依赖项</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard">.NET Standard</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/preprocessor-directives/">C# 预处理器指令</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/create-a-class-library-project-that-supports-multiple-dotnet-versions" data-id="cklbzl1a6000gzonuau43cbp1" data-title="创建支持多个dotnet版本的类库项目" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NET-Standard/" rel="tag">.NET Standard</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-thread-and-thread-pool" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/thread-and-thread-pool" class="article-date">
  <time class="dt-published" datetime="2019-04-03T12:21:00.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/thread-and-thread-pool">线程与线程池</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul>
<li><code>Thread</code> 是前台线程，启动后需要执行完成后才会退出。但是可以通过 <code>IsBackground</code> 将其设置为后台线程，程序退出该线程也会立即退出。</li>
<li>如果希望等待线程执行完成后再继续执行，可以使用 <code>Join()</code> 方法。</li>
<li><code>Thread</code> 没有回调，也没有返回值。</li>
</ul>
<h2 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h2><h3 id="CLR线程池："><a href="#CLR线程池：" class="headerlink" title="CLR线程池："></a>CLR线程池：</h3><p>管理线程开销最好的方式：</p>
<ul>
<li>尽量少的创建线程并且能将线程反复利用(线程池初始化时没有线程，有程序请求线程则创建线程)；</li>
<li>最好不要销毁而是挂起线程达到避免性能损失(线程池创建的线程完成任务后以挂起状态回到线程池中，等待下次请求)；</li>
<li>通过一个技术达到让应用程序一个个执行工作，类似于一个队列(多个应用程序请求线程池，线程池会将各个应用程序排队处理)；</li>
<li>如果某一线程长时间挂起而不工作的话，需要彻底销毁并且释放资源(线程池自动监控长时间不工作的线程，自动销毁)；</li>
<li>如果线程不够用的话能够创建线程，并且用户可以自己定制最大线程创建的数量(当队列过长，线程池里的线程不够用时，线程池不会坐视不理)；</li>
</ul>
<p>实现：</p>
<ul>
<li><code>C#2.0</code> 时支持，实现为享元模式、单例模式。</li>
<li>CLR线程池并不会在CLR初始化时立即建立线程，而是在应用程序要创建线程来运行任务时，线程池才初始化一个线程。</li>
<li>线程池初始化时是没有线程的，线程池里的。线程的初始化与其他线程一样，但是在完成任务以后，该线程不会自行销毁，而是以挂起的状态返回到线程池。直到应用程序再次向线程池发出请求时，线程池里挂起的线程就会再度激活执行任务。这样既节省了建立线程所造成的性能损耗，也可以让多个任务反复重用同一线程，从而在应用程序生存期内节约大量开销。</li>
</ul>
<p><strong>注意：</strong>通过CLR线程池所建立的线程总是默认为后台线程，优先级数为ThreadPriority.Normal。</p>
<h3 id="工作者线程与I-O线程"><a href="#工作者线程与I-O线程" class="headerlink" title="工作者线程与I/O线程"></a>工作者线程与I/O线程</h3><p><code>CLR</code> 线程池分为工作者线程( <code>workerThreads</code> )与 <code>I/O</code> 线程( <code>completionPortThreads</code> )两种:</p>
<ul>
<li>工作者线程：主要用作管理 <code>CLR</code> 内部对象的运作，通常用于计算密集的任务。</li>
<li><code>I/O</code> ( <code>Input</code>/ <code>Output</code> )线程主要用于与外部系统交互信息，如输入输出， <code>CPU</code> 仅需在任务开始的时候，将任务的参数传递给设备，然后启动硬件设备即可。等任务完成的时候， <code>CPU</code> 收到一个通知，一般来说是一个硬件的中断信号，此时 <code>CPU</code> 继续后继的处理工作。在处理过程中， <code>CPU</code> 是不必完全参与处理过程的，如果正在运行的线程不交出 <code>CPU</code> 的控制权，那么线程也只能处于等待状态，即使操作系统将当前的 <code>CPU</code> 调度给其他线程，此时线程所占用的空间还是被占用，而并没有 <code>CPU</code> 处理这个线程，可能出现线程资源浪费的问题。如果这是一个网络服务程序，每一个网络连接都使用一个线程管理，可能出现大量线程都在等待网络通信，随着网络连接的不断增加，处于等待状态的线程将会很消耗尽所有的内存资源。可以考虑使用线程池解决这个问题。</li>
</ul>
<p>线程池的最大值一般默认为1000、2000。当大于此数目的请求时，将保持排队状态，直到线程池里有线程可用。</p>
<p>使用 <code>CLR</code> 线程池的工作者线程一般有两种方式：</p>
<ul>
<li>通过 <code>ThreadPool.QueueUserWorkItem()</code> 方法；</li>
<li>通过委托；</li>
</ul>
<p><strong>注意：</strong>不论是通过ThreadPool.QueueUserWorkItem()还是委托，调用的都是线程池里的线程。</p>
<h3 id="ThreadPool-类常用方法"><a href="#ThreadPool-类常用方法" class="headerlink" title="ThreadPool 类常用方法"></a><code>ThreadPool</code> 类常用方法</h3><p>通过以下两个方法可以读取和设置CLR线程池中工作者线程与I/O线程的最大线程数：</p>
<ul>
<li><code>ThreadPool.GetMax(out in workerThreads,out int completionPortThreads)</code></li>
<li><code>ThreadPool.SetMax(int workerThreads,int completionPortThreads)</code></li>
</ul>
<p>若想测试线程池中有多少线程正在投入使用，可以通过 <code>ThreadPool.GetAvailableThreads(out in workThreads,out int conoletionPortThreads)</code> 方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>GetAvailableThreads</code></td>
<td align="left">剩余空闲线程数</td>
</tr>
<tr>
<td align="left"><code>GetMaxThreads</code></td>
<td align="left">最多可用线程数，所有大于此数目的请求将保持排队状态，直到线程池线程变为可用</td>
</tr>
<tr>
<td align="left"><code>GetMinThreads</code></td>
<td align="left">检索线程池在新请求预测中维护的空闲线程数。</td>
</tr>
<tr>
<td align="left"><code>QueueUserWorkItem</code></td>
<td align="left">启动线程池里得一个线程(队列的方式，如线程池暂时没空闲线程，则进入队列排队)</td>
</tr>
<tr>
<td align="left"><code>SetMaxThreads</code></td>
<td align="left">设置线程池中的最大线程数</td>
</tr>
<tr>
<td align="left"><code>SetMinThreads</code></td>
<td align="left">设置线程池最少需要保留的线程数</td>
</tr>
</tbody></table>
<h3 id="各种调用线程池线程的方法"><a href="#各种调用线程池线程的方法" class="headerlink" title="各种调用线程池线程的方法"></a>各种调用线程池线程的方法</h3><h4 id="通过-QueueUserWorkItem-启动工作者线程"><a href="#通过-QueueUserWorkItem-启动工作者线程" class="headerlink" title="通过 QueueUserWorkItem 启动工作者线程"></a>通过 <code>QueueUserWorkItem</code> 启动工作者线程</h4><p><code>ThreadPool</code> 线程池中有两个重载的静态方法可以直接启动工作者</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool.QueueUserWorkItem(waitCallback);</span><br><span class="line">ThreadPool.QueueUserWorkItem(waitCallback,Object);</span><br></pre></td></tr></table></figure>
<p>通过 <code>ThreadPool.QueueUserWork</code> 启动工作者线程非常方便，但是 <code>WaitCallback</code> 委托指向的必须是一个带有 <code>object</code> 参数的无返回值方法。所以这个方法启动的工作者线程仅仅适合于带单个参数和无返回值的情况。如果要传递多个参数和要有返回值，那就只有通过委托。</p>
<h4 id="BeginInvoke-与-EndInvoke-委托异步调用线程"><a href="#BeginInvoke-与-EndInvoke-委托异步调用线程" class="headerlink" title="BeginInvoke 与 EndInvoke 委托异步调用线程"></a><code>BeginInvoke</code> 与 <code>EndInvoke</code> 委托异步调用线程</h4><ol>
<li>建立一个委托对象，通过 <code>IAsyncResult BeginInvoke(string name,AsyncCallback callback,object state)</code> 异步调用委托方法， <code>BeginInvoke</code> 方法除最后的两个参数外，其他参数都是与方法参数相对应的;</li>
<li>利用 <code>EndInvoke</code> ( <code>IAsyncResult</code> –上一步 <code>BeginInvoke</code> 返回的对象)方法就可以结束异步操作，获取委托的运行结果;</li>
</ol>
<p><strong>缺点：</strong>不知道异步操作什么时候执行完，什么时候开始调用EndInvoke，因为一旦EndInvoke主线程就会处于阻塞等待状态。</p>
<h4 id="IAsyncResult-轮询"><a href="#IAsyncResult-轮询" class="headerlink" title="IAsyncResult 轮询"></a><code>IAsyncResult</code> 轮询</h4><p>克服上面提到的缺点，可以好好利用 <code>IAsyncResult</code> 提高主线程的工作性能：</p>
<ul>
<li><code>IsCompleted</code> 属性：获取异步操作是否已完成；</li>
<li><code>WaitOne</code> ：判断单个异步线程是否完成；</li>
<li><code>WaitAny</code> ：判断是否异步线程是否有指定数量个已完成；</li>
<li><code>WaitAll</code> ：判断是否所有的异步线程已完成；</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>, <span class="built_in">string</span>&gt; func = (name, age) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">20000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">$&quot;My name is <span class="subst">&#123;name&#125;</span>, I&#x27;m <span class="subst">&#123;age&#125;</span> years old.&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">IAsyncResult asyncResult = func.BeginInvoke(<span class="string">&quot;Jane&quot;</span>, <span class="number">12</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//IAsyncResult.IsCompleted属性</span></span><br><span class="line"><span class="keyword">while</span> (!asyncResult.IsCompleted)</span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">500</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*************WAITING*************&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span>/AsyncWaitHandle.WaitOne()方法</span></span><br><span class="line"><span class="comment">//while (!asyncResult.AsyncWaitHandle.WaitOne(200))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    Console.WriteLine(&quot;*************WAITING*************&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>/WaitHandle.WaitAny()方法</span></span><br><span class="line"><span class="comment">//WaitHandle[] waitHandleList1 = new WaitHandle[] &#123; asyncResult.AsyncWaitHandle &#125;;</span></span><br><span class="line"><span class="comment">//while (WaitHandle.WaitAny(waitHandleList1, 200) &gt; 0)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    Console.WriteLine(&quot;*************WAITING*************&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>/WaitHandle.WaitAll()方法</span></span><br><span class="line"><span class="comment">//WaitHandle[] waitHandleList2 = new WaitHandle[] &#123; asyncResult.AsyncWaitHandle &#125;;</span></span><br><span class="line"><span class="comment">//while (WaitHandle.WaitAll(waitHandleList2, 200))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    Console.WriteLine(&quot;*************WAITING*************&quot;);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">Console.WriteLine(func.EndInvoke(asyncResult));</span><br></pre></td></tr></table></figure>
<h4 id="IAsyncResult-回调函数"><a href="#IAsyncResult-回调函数" class="headerlink" title="IAsyncResult 回调函数"></a><code>IAsyncResult</code> 回调函数</h4><p>使用轮询方式来检测异步方法的状态非常麻烦，而且影响了主线程，效率不高。我们可以使用IAsyncResult对象，当异步线程完成了就直接调用实现定义好的处理函数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>, <span class="built_in">string</span>&gt; func = (name, age) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">$&quot;My name is <span class="subst">&#123;name&#125;</span>, I&#x27;m <span class="subst">&#123;age&#125;</span> years old.&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">IAsyncResult asyncResult = <span class="literal">null</span>;</span><br><span class="line">AsyncCallback callback = (t) =&gt; </span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(func.EndInvoke(asyncResult));</span><br><span class="line">&#125;;</span><br><span class="line">asyncResult = func.BeginInvoke(<span class="string">&quot;Jane&quot;</span>, <span class="number">12</span>, callback, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>回调函数依然是在辅助线程中执行的，这样就不会影响主线程的运行。</li>
<li>线程池的线程默认是后台线程。但是如果主线程比辅助线程优先完成，那么程序已经卸载，回调函数未必会执行。如果不希望丢失回调函数中的操作，要么把异步线程设为前台线程，要么确保主线程将比辅助线程迟完成。</li>
</ul>
<h3 id="ManualResetEvent"><a href="#ManualResetEvent" class="headerlink" title="ManualResetEvent"></a><code>ManualResetEvent</code></h3><p>常用方法： <code>Set()</code> 、 <code>ReSet()</code> 、 <code>WaitOne()</code></p>
<ul>
<li><code>Set()</code> : 用于向 <code>ManualResetEvent</code> 发送信号，使其取消阻塞状态（唤醒进程）或者开始阻塞进程，这基于  <code>ManualResetEvent</code> 的初始状态。</li>
<li><code>ReSet()</code> : 将 <code>ManualResetEvent</code> 的状态重置至初始状态（即使用 <code>Set()</code> 方法之前的状态）。</li>
<li><code>WaitOne()</code> : 使 <code>ManualResetEvent</code> 进入阻塞状态，开始等待唤醒信号。如果有信号，则不会阻塞，直接通过。</li>
<li>信号 : 当 <code>new ManualResetEvent(bool arg)</code> 时， <code>arg</code> 参数就是信号状态，假如为 <code>false</code> ，则表示当前无信号，如果为 <code>true</code> ，则有信号。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/thread-and-thread-pool" data-id="cklbzl1by0047zonuatvu22bf" data-title="线程与线程池" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-asynchronous-and-multithreading" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/asynchronous-and-multithreading" class="article-date">
  <time class="dt-published" datetime="2019-04-02T14:18:00.000Z" itemprop="datePublished">2019-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/asynchronous-and-multithreading">异步多线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>首先打开任务管理器，可以查看电脑当前运行的进程。  </p>
<p>从任务管理器里面可以看到当前所有正在运行的进程。</p>
<p><strong>那么究竟什么是进程呢？</strong></p>
<p>进程( <code>Process</code> )是 <code>Windows</code> 系统中的一个基本概念，它包含着一个运行程序所需要的资源。一个正在运行的应用程序在操作系统中被视为一个进程，进程可以包括一个或多个线程。  </p>
<p>线程是操作系统分配处理器时间的基本单元，在进程中可以有多个线程同时执行代码。进程之间是相对独立的，一个进程无法访问另一个进程的数据(除非利用分布式计算方式)，一个进程运行的失败也不会影响其他进程的运行， <code>Windows</code> 系统就是利用进程把工作划分为多个独立的区域的。  </p>
<p>进程可以理解为一个程序的基本边界。是应用程序的一个运行例程，是应用程序的一次动态执行过程。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在任务管理器， 性能 -&gt; <code>CPU</code> 中可以查看当前电脑当前运行的线程数量。  </p>
<p>线程( <code>Thread</code> )是进程中的基本执行单元，是操作系统分配 <code>CPU</code> 时间的基本单位，一个进程可以包含若干个线程，在进程入口执行的第一个线程被视为这个进程的主线程。  </p>
<p>在 <code>.NET</code> 应用程序中，都是以 <code>Main()</code> 方法作为入口的，当调用此方法时系统就会自动创建一个主线程。线程主要是由 <code>CPU</code> 寄存器、调用栈和线程本地存储器( <code>Thread Local Storage</code> ， <code>TLS</code> )组成的。  </p>
<p><code>CPU</code> 寄存器主要记录当前所执行线程的状态，调用栈主要用于维护线程所调用到的内存与数据， <code>TLS</code> 主要用于存放线程的状态信息。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h3><p>多线程的优点：</p>
<ul>
<li>可以同时完成多个任务；</li>
<li>可以使程序的响应速度更快；</li>
<li>可以让占用大量处理时间的任务或当前没有进行处理的任务定期将处理时间让给别的任务；</li>
<li>可以随时停止任务；</li>
<li>可以设置每个任务的优先级以优化程序性能。</li>
</ul>
<p>那么可能有人会问：为什么可以多线程执行呢？</p>
<p>总结起来有下面两方面的原因：</p>
<ul>
<li>CPU运行速度太快，硬件处理速度跟不上，所以操作系统进行分时间片管理。这样，从宏观角度来说是多线程并发的，因为CPU速度太快，察觉不到，看起来是同一时刻执行了不同的操作。但是从微观角度来讲，同一时刻只能有一个线程在处理。</li>
<li>目前电脑都是多核多CPU的，一个CPU在同一时刻只能运行一个线程，但是多个CPU在同一时刻就可以运行多个线程。</li>
</ul>
<p>然而，多线程虽然有很多优点，但是也必须认识到多线程可能存在影响系统性能的不利方面，才能正确使用线程。</p>
<p>不利方面主要有如下几点：</p>
<ul>
<li>线程也是程序，所以线程需要占用内存，线程越多，占用内存也越多。</li>
<li>多线程需要协调和管理，所以需要占用CPU时间以便跟踪线程。</li>
<li>线程之间对共享资源的访问会相互影响，必须解决争用共享资源的问题。</li>
<li>线程太多会导致控制太复杂，最终可能造成很多程序缺陷。</li>
</ul>
<h4 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h4><p>当启动一个可执行程序时，将创建一个主线程。在默认的情况下， <code>C#</code> 程序具有一个线程，此线程执行程序中以 <code>Main</code> 方法开始和结束的代码， <code>Main()</code> 方法直接或间接执行的每一个命令都有默认线程(主线程)执行，当 <code>Main()</code> 方法返回时此线程也将终止。  </p>
<p>一个进程可以创建一个或多个线程以执行与该进程关联的部分程序代码。在 <code>C#</code> 中，线程是使用 <code>Thread</code> 类处理的，该类在 <code>System.Threading</code> 命名空间中。  </p>
<p>使用 <code>Thread</code> 类创建线程时，只需要提供线程入口，线程入口告诉程序让这个线程做什么。通过实例化一个 <code>Thread</code> 类的对象就可以创建一个线程。  </p>
<p>创建新的 <code>Thread</code> 对象时，将创建新的托管线程。 <code>Thread</code> 类接收一个 <code>ThreadStart</code> 委托或 <code>ParameterizedThreadStart</code> 委托的构造函数，该委托包装了调用 <code>Start</code> 方法时由新线程调用的方法，示例代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(method));<span class="comment">//创建线程</span></span><br><span class="line">thread.Start();                                   <span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>
<p>上面代码实例化了一个 <code>Thread</code> 对象，并指明将要调用的方法 <code>method()</code> ，然后启动线程。 <code>ThreadStart</code> 委托中作为参数的方法不需要参数，并且没有返回值。 <code>ParameterizedThreadStart</code> 委托一个对象作为参数，利用这个参数可以很方便地向线程传递参数，示例代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> ParameterizedThreadStart(method));<span class="comment">//创建线程</span></span><br><span class="line">thread.Start(<span class="number">3</span>);                                               <span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure>
<p>创建多线程的步骤：</p>
<ol>
<li>编写线程所要执行的方法</li>
<li>实例化 <code>Thread</code> 类，并传入一个指向线程所要执行方法的委托。(这时线程已经产生，但还没有运行)</li>
<li>调用 <code>Thread</code> 实例的 <code>Start</code> 方法，标记该线程可以被 <code>CPU</code> 执行了，但具体执行时间由 <code>CPU</code> 决定</li>
</ol>
<h3 id="System-Threading-Thread-类"><a href="#System-Threading-Thread-类" class="headerlink" title="System.Threading.Thread 类"></a><code>System.Threading.Thread</code> 类</h3><p>Thread类是是控制线程的基础类，位于System.Threading命名空间下，具有4个重载的构造函数：</p>
<ul>
<li><code>Thread(ParameterizedThreadStart)</code> 初始化 <code>Thread</code> 类的新实例，指定允许对象在线程启动时传递给线程的委托。要执行的方法是有参的。</li>
<li><code>Thread(ParameterizedThreadStart, Int32)</code> 初始化 <code>Thread</code> 类的新实例，指定允许对象在线程启动时传递给线程的委托，并指定线程的最大堆栈大小。</li>
<li><code>Thread(ThreadStart)</code> 初始化 <code>Thread</code> 类的新实例。要执行的方法是无参的。</li>
<li><code>Thread(ThreadStart, Int32)</code> 初始化 <code>Thread</code> 类的新实例，指定线程的最大堆栈大小。</li>
<li><code>ThreadStart</code> 是一个无参的、返回值为 <code>void</code> 的委托。</li>
<li><code>ParameterizedThreadStart</code> 是一个有参的、返回值为 <code>void</code> 的委托。</li>
</ul>
<p><strong>注意：</strong> <code>ParameterizedThreadStart</code> 委托的参数类型必须是 <code>Object</code> 的。如果使用的是不带参数的委托，不能使用带参数的 <code>Start</code> 方法运行线程，否则系统会抛出异常。但使用带参数的委托，可以使用 <code>thread.Start()</code> 来运行线程，这时所传递的参数值为 <code>null</code> 。</p>
<h3 id="线程的常用属性"><a href="#线程的常用属性" class="headerlink" title="线程的常用属性"></a>线程的常用属性</h3><ul>
<li><code>CurrentContext</code> 获取线程正在其中执行的当前上下文。</li>
<li><code>CurrentThread</code> 获取当前正在运行的线程。</li>
<li><code>ExecutionContext</code> 获取一个 <code>ExecutionContext</code> 对象，该对象包含有关当前线程的各种上下文的信息。</li>
<li><code>IsAlive</code> 获取一个值，该值指示当前线程的执行状态。</li>
<li><code>IsBackground</code> 获取或设置一个值，该值指示某个线程是否为后台线程。</li>
<li><code>IsThreadPoolThread</code> 获取一个值，该值指示线程是否属于托管线程池。</li>
<li><code>ManagedThreadId</code> 获取当前托管线程的唯一标识符。</li>
<li><code>Name</code> 获取或设置线程的名称。</li>
<li><code>Priority</code> 获取或设置一个值，该值指示线程的调度优先级。</li>
<li><code>ThreadState</code> 获取一个值，该值包含当前线程的状态。</li>
</ul>
<h4 id="线程的标识符"><a href="#线程的标识符" class="headerlink" title="线程的标识符"></a>线程的标识符</h4><p><code>ManagedThreadId</code> 是确认线程的唯一标识符，程序在大部分情况下都是通过 <code>Thread.ManagedThreadId</code> 来辨别线程的。而Name是一个可变值，在默认时候， <code>Name</code> 为一个空值 <code>Null</code> ，开发人员可以通过程序设置线程的名称，但这只是一个辅助功能。</p>
<h4 id="线程的优先级别"><a href="#线程的优先级别" class="headerlink" title="线程的优先级别"></a>线程的优先级别</h4><p>当线程之间争夺 <code>CPU</code> 时间时， <code>CPU</code> 按照线程的优先级给予服务。高优先级的线程可以完全阻止低优先级的线程执行。</p>
<p><code>.NET</code> 为线程设置了 <code>Priority</code> 属性来定义线程执行的优先级别，里面包含5个选项，其中 <code>Normal</code> 是默认值。除非系统有特殊要求，否则不应该随便设置线程的优先级别。</p>
<ul>
<li><code>Lowest</code> 可以将 <code>Thread</code> 安排在具有任何其他优先级的线程之后。</li>
<li><code>BelowNormal</code> 可以将 <code>Thread</code> 安排在具有 <code>Normal</code> 优先级的线程之后，在具有 <code>Lowest</code> 优先级的线程之前。</li>
<li><code>Normal</code> 默认选择。可以将 <code>Thread</code> 安排在具有 <code>AboveNormal</code> 优先级的线程之后，在具有 <code>BelowNormal</code> 优先级的线程之前。</li>
<li><code>AboveNormal</code> 可以将 <code>Thread</code> 安排在具有 <code>Highest</code> 优先级的线程之后，在具有 <code>Normal</code> 优先级的线程之前。</li>
<li><code>Highest</code>     可以将 <code>Thread</code> 安排在具有任何其他优先级的线程之前。</li>
</ul>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>通过 <code>ThreadState</code> 可以检测线程是处于 <code>Unstarted</code> 、 <code>Sleeping</code> 、 <code>Running</code> 等等状态，它比 <code>IsAlive</code> 属性能提供更多的特定信息。  </p>
<p>前面说过，一个应用程序域中可能包括多个上下文，而通过 <code>CurrentContext</code> 可以获取线程当前的上下文。</p>
<p><code>CurrentThread</code> 是最常用的一个属性，它是用于获取当前运行的线程。</p>
<h4 id="System-Threading-Thread-的方法"><a href="#System-Threading-Thread-的方法" class="headerlink" title="System.Threading.Thread 的方法"></a><code>System.Threading.Thread</code> 的方法</h4><p><code>Thread</code> 中包括了多个方法来控制线程的创建、挂起、停止、销毁，以后来的例子中会经常使用。</p>
<ul>
<li><code>Abort()</code> 终止本线程。</li>
<li><code>GetDomain()</code> 返回当前线程正在其中运行的当前域。</li>
<li><code>GetDomainId()</code> 返回当前线程正在其中运行的当前域Id。</li>
<li><code>Interrupt()</code> 中断处于 <code>WaitSleepJoin</code> 线程状态的线程。</li>
<li><code>Join()</code> 已重载。 阻塞调用线程，直到某个线程终止时为止。</li>
<li><code>Resume()</code> 继续运行已挂起的线程。</li>
<li><code>Start()</code> 执行本线程。</li>
<li><code>Suspend()</code> 挂起当前线程，如果当前线程已属于挂起状态则此不起作用</li>
<li><code>Sleep()</code> 把正在运行的线程挂起一段时间。</li>
</ul>
<h3 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h3><ul>
<li>前台线程：只有所有的前台线程都结束，应用程序才能结束。默认情况下创建的线程都是前台线程。</li>
<li>后台线程：只要所有的前台线程结束，后台线程自动结束。通过 <code>Thread.IsBackground</code> 设置后台线程。必须在调用 <code>Start</code> 方法之前设置线程的类型，否则一旦线程运行，将无法改变其类型。通过 <code>BeginXXX</code> 方法运行的线程都是后台线程。后台线程一般用于处理不重要的事情，应用程序结束时，后台线程是否执行完成对整个应用程序没有影响。如果要执行的事情很重要，需要将线程设置为前台线程。</li>
</ul>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>所谓同步：是指在某一时刻只有一个线程可以访问变量。  </p>
<p>如果不能确保对变量的访问是同步的，就会产生错误。  </p>
<p><code>C#</code> 为同步访问变量提供了一个非常简单的方式，即使用 <code>C#</code> 语言的关键字 <code>Lock</code> ，它可以把一段代码定义为互斥段，互斥段在一个时刻内只允许一个线程进入执行，而其他线程必须等待。在 <code>C#</code> 中，关键字 <code>Lock</code> 定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lock(expression)</span><br><span class="line">&#123;</span><br><span class="line">    statement_block</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>expression</code> 代表你希望跟踪的对象：如果你想保护一个类的实例，一般地，你可以使用 <code>this</code> ；如果你想保护一个静态变量(如互斥代码段在一个静态方法内部)，一般使用类名就可以了。而 <code>statement_block</code> 就算互斥段的代码，这段代码在一个时刻内只可能被一个线程执行。</p>
<h3 id="跨线程访问"><a href="#跨线程访问" class="headerlink" title="跨线程访问"></a>跨线程访问</h3><p>创建窗体应用程序，增加一个测试按钮和一个文本框，点击“测试”，创建一个线程，从0循环到10000给文本框赋值，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn_Test_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建一个线程去执行这个方法:创建的线程默认是前台线程</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(Test));</span><br><span class="line">    <span class="comment">//Start方法标记这个线程就绪了，可以随时被执行，具体什么时候执行这个线程，由CPU决定</span></span><br><span class="line">    <span class="comment">//将线程设置为后台线程</span></span><br><span class="line">    thread.IsBackground = <span class="literal">true</span>;</span><br><span class="line">    thread.Start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    &#123;               </span><br><span class="line">        <span class="keyword">this</span>.textBox1.Text = i.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行结果会报错：线程间操作无效：不是创建“textBox1”的线程访问它。  </p>
</blockquote>
<blockquote>
<p>产生错误的原因：textBox1是由主线程创建的，thread线程是另外创建的一个线程，在.NET上执行的是托管代码，C#强制要求这些代码必须是线程安全的，即不允许跨线程访问Windows窗体的控件。</p>
</blockquote>
<p>解决方案：</p>
<ol>
<li>在窗体的加载事件中，将 <code>C#</code> 内置控件( <code>Control</code> )类的 <code>CheckForIllegalCrossThreadCalls</code> 属性设置为 <code>false</code> ，屏蔽掉 <code>C#</code> 编译器对跨线程调用的检查。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Form1_Load</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//取消跨线程的访问</span></span><br><span class="line">       Control.CheckForIllegalCrossThreadCalls = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用上述的方法虽然可以保证程序正常运行并实现应用的功能，但是在实际的软件开发中，做如此设置是不安全的(不符合 <code>.NET</code> 的安全规范)，在产品软件的开发中，此类情况是不允许的。如果要在遵守.NET安全标准的前提下，实现从一个线程成功地访问另一个线程创建的空间，要使用 <code>C#</code> 的方法回调机制。</p>
</blockquote>
<ol start="2">
<li>使用回调函数</li>
</ol>
<p>回调实现的一般过程： <code>C#</code> 的方法回调机制，也是建立在委托基础上的，下面给出它的典型实现过程。</p>
<ul>
<li>定义、声明回调。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义回调</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DoSomeCallBack</span>(<span class="params">Type para</span>)</span>;</span><br><span class="line"><span class="comment">//声明回调</span></span><br><span class="line">DoSomeCallBack doSomaCallBack;</span><br></pre></td></tr></table></figure>
<p>可以看出，这里定义声明的“回调”( <code>doSomaCallBack</code> )其实就是一个委托。</p>
<ul>
<li>初始化回调方法。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doSomeCallBack = <span class="keyword">new</span> DoSomeCallBack(DoSomeMethod);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所谓“初始化回调方法”实际上就是实例化刚刚定义了的委托，这里作为参数的 <code>DoSomeMethod</code> 称为“回调方法”，它封装了对另一个线程中目标对象（窗体控件或其他类）的操作代码。</p>
</blockquote>
<ul>
<li>触发对象动作</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opt obj.Invoke(doSomeCallBack, arg);</span><br></pre></td></tr></table></figure>
<p>其中 <code>Opt obj</code> 为目标操作对象，在此假设它是某控件，故调用其 <code>Invoke</code> 方法。 <code>Invoke</code> 方法签名为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> Control.Invoke(Delegate method, <span class="keyword">params</span> <span class="built_in">object</span>[] args);</span><br></pre></td></tr></table></figure>
<p>它的第一个参数为委托类型，可见“触发对象动作”的本质，就是把委托 <code>doSomeCallBack</code> 作为参数传递给控件的 <code>Invoke</code> 方法，这与委托的使用方式是一模一样的。<br>最终作用于对象 <code>Opt obj</code> 的代码是置于回调方法体 <code>DoSomeMethod()</code> 中的，如下所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoSomeMethod</span>(<span class="params">type para</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    Opt obj.someMethod(para);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不用回调，而是直接在程序中使用 <code>Opt obj.someMethod(para);</code> ，则当对象 <code>Opt obj</code> 不在本线程（跨线程访问）时就会发生上面所示的错误。</p>
<p>从以上回调实现的一般过程可知： <code>C#</code> 的回调机制，实质上是委托的一种应用。在 <code>C#</code> 网络编程中，回调的应用是非常普遍的，有了方法回调，就可以在 <code>.NET</code> 上写出线程安全的代码了。</p>
<p>使用方法回调，实现给文本框赋值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MultiThreadDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Form1</span> : <span class="title">Form</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义回调</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">setTextValueCallBack</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">        <span class="comment">//声明回调</span></span><br><span class="line">        <span class="keyword">private</span> setTextValueCallBack setCallBack;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btn_Test_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//实例化回调</span></span><br><span class="line">            setCallBack = <span class="keyword">new</span> setTextValueCallBack(SetValue);</span><br><span class="line">            <span class="comment">//创建一个线程去执行这个方法:创建的线程默认是前台线程</span></span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(Test));</span><br><span class="line">            <span class="comment">//Start方法标记这个线程就绪了，可以随时被执行，具体什么时候执行这个线程，由CPU决定</span></span><br><span class="line">            <span class="comment">//将线程设置为后台线程</span></span><br><span class="line">            thread.IsBackground = <span class="literal">true</span>;</span><br><span class="line">            thread.Start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;               </span><br><span class="line">                <span class="comment">//使用回调</span></span><br><span class="line">                textBox1.Invoke(setCallBack, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 定义回调使用的方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;value&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetValue</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.textBox1.Text = <span class="keyword">value</span>.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>若想终止正在运行的线程，可以使用 <code>Abort()</code> 方法。</p>
<h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步和异步是对方法执行顺序的描述。</p>
<p>同步：等待上一行完成计算之后，才会进入下一行。</p>
<blockquote>
<p>例如：请同事吃饭，同事说很忙，然后就等着同事忙完，然后一起去吃饭。</p>
</blockquote>
<p>异步：不会等待方法的完成，会直接进入下一行，是非阻塞的。</p>
<blockquote>
<p>例如：请同事吃饭，同事说很忙，那同事先忙，自己去吃饭，同事忙完了他自己去吃饭。</p>
</blockquote>
<p>同步方法和异步方法的区别：</p>
<ol>
<li><ul>
<li>同步方法由于主线程忙于计算，所以会卡住界面。</li>
<li>异步方法由于主线程执行完了，其他计算任务交给子线程去执行，所以不会卡住界面，用户体验性好。</li>
</ul>
</li>
<li><ul>
<li>同步方法由于只有一个线程在计算，所以执行速度慢。</li>
<li>异步方法由多个线程并发运算，所以执行速度快，但并不是线性增长的（资源可能不够）。多线程也不是越多越好，只有多个独立的任务同时运行，才能加快速度。</li>
</ul>
</li>
<li><ul>
<li>同步方法是有序的。</li>
<li>异步多线程是无序的：启动无序，执行时间不确定，所以结束也是无序的。一定不要通过等待几毫秒的形式来控制线程启动/执行时间/结束。</li>
</ul>
</li>
</ol>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><ul>
<li>异步多线程是无序的，可以通过使用回调解决异步多线程是无序的问题。</li>
<li>获取委托异步调用的返回值：使用 <code>EndInvoke()</code> 可以获取委托异步调用的返回值。注意调用该方法会等待异步执行完成，所以在主线程中执行，会强制等待委托执行完成，而在回调中执行因为委托其实已经执行完成，所以此时 <code>EndInvoke()</code> 单纯为了获取委托执行的结果。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/asynchronous-and-multithreading" data-id="cklbzl1el00c5zonu02ghdzkr" data-title="异步多线程" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-review-of-object-oriented-knowledge-points" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/review-of-object-oriented-knowledge-points" class="article-date">
  <time class="dt-published" datetime="2019-04-02T14:01:00.000Z" itemprop="datePublished">2019-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/review-of-object-oriented-knowledge-points">面向对象知识点回顾</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul>
<li><code>public</code> ：完全公开</li>
<li><code>private</code> ：只有类内部能够访问</li>
<li><code>internal</code> ：同项目中能够访问</li>
<li><code>protected</code> ：类和派生类可以访问</li>
<li><code>protected internal</code> ：internal和protected二者的结合</li>
</ul>
<h3 id="封装-1"><a href="#封装-1" class="headerlink" title="封装"></a>封装</h3><p>封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中(我们称之为类)。被封装的对象通常被称为抽象数据类型。</p>
<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。  </p>
<p>封装提供了一个有效的途径来保护数据不被意外的破坏。相比我们将数据(用域来实现)在程序中定义为公用的( <code>public</code> )我们将它们( <code>fields</code> )定义为私有的( <code>privat</code> )在很多方面会更好。私有的数据可以用两种方式来间接的控制。  </p>
<p>第一种方法，我们使用传统的存、取方法。第二种方法我们用属性（property）。使用属性不仅可以控制存取数据的合法性，同时也提供了“读写”、“只读”、“只写”灵活的操作方法。继承：继承主要实现重用代码，节省开发时间</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h3><p>继承主要实现重用代码，节省开发时间。</p>
<h3 id="继承的规则"><a href="#继承的规则" class="headerlink" title="继承的规则"></a>继承的规则</h3><p>继承是可传递的。如果 <code>C</code> 从 <code>B</code> 中派生， <code>B</code> 又从 <code>A</code> 中派生，那么 <code>C</code> 不仅继承了 <code>B</code> 中声明的成员，同样也继承了 <code>A</code> 中的成员。 <code>object</code> 类作为所有类的基类。  </p>
<p>派生类应当是对基类的扩展。派生类可以添加新的成员，但不能除去已经继承的成员的定义。  </p>
<p>构造函数和析构函数不能被继承。除此之外的其它成员，不论对它们定义了怎样的访问方式，都能被继承。基类中成员的访问方式只能决定派生类能否访问它们。  </p>
<p>派生类如果定义了与继承而来的成员同名的新成员，就可以覆盖已继承的成员。但这并不因为这派生类删除了这些成员，只是不能再访问这些成员。  </p>
<p>类可以定义虚方法、虚属性以及虚索引指示器，它的派生类能够重载这些成员，从而实现类可以展示出多态性。</p>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul>
<li>重载：继承中的重载和类内的成员方法的重载是一样的，只要在子类中新建了和父类中同名的但参数列表不同的成员方法就重载了父类的成员方法，但前题是要能继承该成员方法。</li>
<li>重写：是在子类中重新改写从父类中继承过来的某个方法，用新的方法代替原有的方法，这里要用关键字virtual override。</li>
<li>隐藏：也是在子类中重新改写从父类中继承过来的某个方法，但不是把父类的方法替换掉，而是隐藏起来，要用关键字new。</li>
<li>base：可以调用父类的成员方法，除了构造函数和析构函数，派生类将隐式的继承了继承基类的所有成员。也可以显示的调用父类的构造函数来构造子类的成员数据。</li>
<li>this：引用类当前的实例，还用于将对象传递到属于其他类的方法。</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="new-的用法"><a href="#new-的用法" class="headerlink" title="new 的用法"></a><code>new</code> 的用法</h3><p>当派生类与基类型相同的方法使用 <code>new</code> 修饰时，派生类对象转换后，调用的是基类的方法。其实可以理解为，使用 <code>new</code> 关键字后，使得派生类中的方法和基类中的方法成为毫不相关的两个方法，只是它们的名字碰巧相同而已。所以，基类中的方法不管用还是不用 <code>virtual</code> 修饰，也不管访问权限如何，或者是没有，都不会对派生类的方法产生什么影响(只是因为使用了 <code>new</code> 关键字，如果派生类没用 <code>new</code> 关键字从基类继承同名方法，编译器会输出警告)。这可能是设计者有意这么设计的，因为有时候我们就是要达到这种效果。严格的说，不能说通过使用 <code>new</code> 来实现多态，只能说在某些特定的时候碰巧实现了多态的效果。</p>
<h3 id="override-实现多态"><a href="#override-实现多态" class="headerlink" title="override 实现多态"></a><code>override</code> 实现多态</h3><p>真正的多态使用 <code>override</code> 来实现的，在基类中将方法用virtual标记为虚拟方法，再在派生类中用 <code>override</code> 对需要重写的方法修饰进行重写，就可以很简单的实现多态。需要注意的是，要对一个类中一个方法用 <code>override</code> 修饰，该类必须从父类中继承了一个对应的用 <code>virtual</code> 修饰的虚拟方法，否则编译器将报错。如果父类方法用 <code>override</code> 修饰，如果子类继承了该方法，也可以用 <code>override</code> 修饰，多层继承中的多态就是这样实现的。要想终止这种重写，只需重写方法时用 <code>sealed</code> 关键字进行修饰即可。</p>
<h3 id="abstract-override-实现多态"><a href="#abstract-override-实现多态" class="headerlink" title="abstract-override 实现多态"></a><code>abstract-override</code> 实现多态</h3><p><code>abstract</code> 修饰的抽象方法只是对方法进行了定义，而没有实现，如果一个类包含了抽象方法，那么该类也必须用 <code>abstract</code> 声明为抽象类，一个抽象类是不能被实例化的。对于类中的抽象方法，可以再其派生类中用 <code>override</code> 进行重写，如果不重写，其派生类也要被声明为抽象类。</p>
<p><code>abstract-override</code> 可以和 <code>virtual-override</code> 一样地实现多态，包括多层继承也是一样的。不同之处在于，包含虚拟方法的类可以被实例化，而包含抽象方法的类不能被实例化。</p>
<h3 id="接口实现多态"><a href="#接口实现多态" class="headerlink" title="接口实现多态"></a>接口实现多态</h3><p>接口存在的意义就是为了实现多态，另外接口解决了类的多继承问题，解决了类继承以后体积庞大的问题，接口之间可以实现多继承。接口中的成员必须不能有实现，接口不能实例化，成员不能有访问修饰符(隐式公开)，接口中可以有属性，方法，索引器等(属性，索引器本质上也是方法)，但不能有字段，接口中的所有方法必须被子类中全部实现(除非子类是抽象类，把接口中的成员标记为抽象的)。一个类只能继承一个父类，但是可以实现多个接口，接口只能决定能干什么，怎么干由类来实现。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>接口是一种规范。为了多态。</li>
<li>接口不能被实例化。</li>
<li>接口中的成员不能加“访问修饰符”，接口中的成员访问修饰符为 <code>public</code> ，不能修改。(默认为 <code>public</code> )</li>
<li>接口中的成员不能有任何实现（“光说不做”，只是定义了一组未实现的成员）。</li>
<li>接口中只能有方法、属性、索引器、事件，不能有“字段”。</li>
<li>接口与接口之间可以继承，并且可以多继承。</li>
<li>实现接口的子类必须实现该接口的全部成员。</li>
<li>一个类可以同时继承一个类并实现多个接口，如果一个子类同时继承了父类 <code>A</code> ，并实现了接口 <code>IA</code> ,那么语法上A必须写在 <code>IA</code> 的前面。 <code>class MyClass:A,IA&#123;&#125;</code> ，因为类是单继承的。</li>
<li>当一个抽象类实现接口的时候，如果不想把接口中的成员实现，可以把该成员实现为 <code>abstract</code> 。(抽象类也能实现接口，用 <code>abstrac</code> 标记)</li>
<li>“显示实现接口”，只能通过接口变量来调用 (因为显示实现接口后成员为 <code>private</code> )。</li>
</ol>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ol>
<li><p>抽象类适用于同一系列，并且有需要继承的成员。</p>
</li>
<li><p>接口适用于不同系列的类具有相同的动作(行为、动作、方法)。对于不是相同的系列，但具有相同的行为，这个就考虑使用接口。</p>
</li>
<li><p>接口解决了类不能多继承问题。</p>
</li>
<li><p>接口定义类的公共行为，抽象类定义类的公共实现。</p>
</li>
<li><p>一个类只能继承自一个类(抽象类)，但是可以同时实现多个接口。</p>
</li>
<li><p>接口中不能有实现，抽象类中可以有未实现成员也可以有实现的成员。</p>
</li>
<li><p>接口中未实现的方法必须在子类中实现，抽象类中未实现的成员必须在子类中重写。</p>
<h3 id="接口和类的异同"><a href="#接口和类的异同" class="headerlink" title="接口和类的异同"></a>接口和类的异同</h3></li>
</ol>
<ul>
<li>不同点：不能直接实例化接口。接口不包含方法的实现。接口可以多继承，类只能单继承。类定义可在不同的源文件之间进行拆分。</li>
<li>相同点：接口、类和结构都可以从多个接口继承。接口类似于抽象基类：继承接口的任何非抽象类型都必须实现接口的所有成员。接口和类都可以包含事件、索引器、方法和属性。</li>
</ul>
<p><strong>C#支持多重继承么？</strong></p>
<p>类之间不支持，接口之间支持。类对接口叫做实现，不叫继承。类是父亲、接口是能力，能有多个能力，但不能有多个父亲。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/review-of-object-oriented-knowledge-points" data-id="cklbzl1bn003gzonu604g0lcw" data-title="面向对象知识点回顾" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OOP/" rel="tag">OOP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-common-serializer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/common-serializer" class="article-date">
  <time class="dt-published" datetime="2019-04-02T13:54:00.000Z" itemprop="datePublished">2019-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/common-serializer">常见序列化器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="常见序列化器"><a href="#常见序列化器" class="headerlink" title="常见序列化器"></a>常见序列化器</h2><h3 id="二进制序列化器"><a href="#二进制序列化器" class="headerlink" title="二进制序列化器"></a>二进制序列化器</h3><p>命名空间 <code>System.Runtime.Serialization.Formatters.Binary;</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="keyword">using</span> (FileStream fileStream = <span class="keyword">new</span> FileStream(path, FileMode.Create, FileAccess.ReadWrite))</span><br><span class="line">&#123;</span><br><span class="line">    BinaryFormatter binaryFormatter = <span class="keyword">new</span> BinaryFormatter();<span class="comment">//创建二进制序列化器</span></span><br><span class="line">    binaryFormatter.Serialize(fileStream, ListPersons);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">using</span> (FileStream fileStream = <span class="keyword">new</span> FileStream(path, FileMode.Open, FileAccess.ReadWrite))</span><br><span class="line">&#123;</span><br><span class="line">    BinaryFormatter binaryFormatter = <span class="keyword">new</span> BinaryFormatter();<span class="comment">//创建二进制序列化器</span></span><br><span class="line">    fileStream.Position = <span class="number">0</span>;<span class="comment">//重置流位置</span></span><br><span class="line">    List&lt;Human&gt; list = (List&lt;Human&gt;)binaryFormatter.Deserialize(fileStream);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        item.Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Soap-序列化器"><a href="#Soap-序列化器" class="headerlink" title="Soap 序列化器"></a><code>Soap</code> 序列化器</h3><p>命名空间 <code>System.Runtime.Serialization.Formatters.Soap;</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="keyword">using</span> (FileStream fileStream = <span class="keyword">new</span> FileStream(path, FileMode.Create, FileAccess.ReadWrite))</span><br><span class="line">&#123;</span><br><span class="line">    SoapFormatter soapFormatter = <span class="keyword">new</span> SoapFormatter();<span class="comment">//创建Soap序列化器</span></span><br><span class="line">    soapFormatter.Serialize(fileStream, ListPersons.ToArray());<span class="comment">//不支持泛型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">using</span> (FileStream fileStream = <span class="keyword">new</span> FileStream(path, FileMode.Open, FileAccess.ReadWrite))</span><br><span class="line">&#123;</span><br><span class="line">    SoapFormatter soapFormatter = <span class="keyword">new</span> SoapFormatter();<span class="comment">//创建Soap序列化器</span></span><br><span class="line">    fileStream.Position = <span class="number">0</span>;<span class="comment">//重置流位置</span></span><br><span class="line">    List&lt;Human&gt; list = ((Human[])soapFormatter.Deserialize(fileStream)).ToList();<span class="comment">//不支持泛型</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        item.Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="XML序列化器"><a href="#XML序列化器" class="headerlink" title="XML序列化器"></a>XML序列化器</h3><p>命名空间： <code>System.Xml.Serialization;</code>  </p>
<p><strong>XML：标记语言</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="keyword">using</span> (FileStream fileStream = <span class="keyword">new</span> FileStream(path, FileMode.Create, FileAccess.ReadWrite))</span><br><span class="line">&#123;</span><br><span class="line">    XmlSerializer xmlSerializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(List&lt;Human&gt;));<span class="comment">//创建Xml序列化器 需要指定对象的类型</span></span><br><span class="line">    xmlSerializer.Serialize(fileStream, ListPersons);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">using</span> (FileStream fileStream = <span class="keyword">new</span> FileStream(path, FileMode.Open, FileAccess.ReadWrite))</span><br><span class="line">&#123;</span><br><span class="line">    XmlSerializer xmlSerializer = <span class="keyword">new</span> XmlSerializer(<span class="keyword">typeof</span>(List&lt;Human&gt;));<span class="comment">//创建Xml序列化器 需要指定对象的类型</span></span><br><span class="line">    fileStream.Position = <span class="number">0</span>;<span class="comment">//重置流位置</span></span><br><span class="line">    List&lt;Human&gt; list = (List&lt;Human&gt;)xmlSerializer.Deserialize(fileStream);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        item.Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Json-序列化器"><a href="#Json-序列化器" class="headerlink" title="Json 序列化器"></a><code>Json</code> 序列化器</h3><p>命名空间：<code>System.Web.Script.Serialization;</code> 或引用 <code>System.Web.Extentsion;</code> 或者 <code>Newtonsoft.Json;</code></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JavaScriptSerializer序列化</span></span><br><span class="line">&#123;<span class="comment">//内置</span></span><br><span class="line">    JavaScriptSerializer javaScriptSerializer = <span class="keyword">new</span> JavaScriptSerializer();<span class="comment">//创建Json序列化器</span></span><br><span class="line">    <span class="built_in">string</span> sJson = javaScriptSerializer.Serialize(ListPersons);</span><br><span class="line">    File.WriteAllText(path1, sJson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JavaScriptSerializer反序列化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> sText = File.ReadAllText(path1);</span><br><span class="line">    JavaScriptSerializer javaScriptSerializer = <span class="keyword">new</span> JavaScriptSerializer();<span class="comment">//创建Json序列化器</span></span><br><span class="line">    List&lt;Human&gt; list = javaScriptSerializer.Deserialize&lt;List&lt;Human&gt;&gt;(sText);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        item.Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Newtonsoft.Json序列化</span></span><br><span class="line">&#123;<span class="comment">//nuget</span></span><br><span class="line">    <span class="built_in">string</span> sJson = JsonConvert.SerializeObject(ListPersons);</span><br><span class="line">    File.WriteAllText(path2, sJson);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Newtonsoft.Json反序列化</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> sText = File.ReadAllText(path1);</span><br><span class="line">    List&lt;Human&gt; list = JsonConvert.DeserializeObject&lt;List&lt;Human&gt;&gt;(sText);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">    &#123;</span><br><span class="line">        item.Action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>常用 <code>Newtonsoft.Json</code> ，因其效率高于内置的 <code>JavaScriptSerializer</code> ，另如果使用内置序列化器，需要对应序列化的类型指定 <code>[Serializable]</code> 的特性。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/common-serializer" data-id="cklbzl1a3000czonu1lob5xk5" data-title="常见序列化器" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Json/" rel="tag">Json</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Xml/" rel="tag">Xml</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" rel="tag">序列化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-file-operations-in-csharp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/file-operations-in-csharp" class="article-date">
  <time class="dt-published" datetime="2019-04-02T10:01:00.000Z" itemprop="datePublished">2019-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/file-operations-in-csharp">C#中的文件操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="文件夹-文件-操作"><a href="#文件夹-文件-操作" class="headerlink" title="文件夹/文件 操作"></a>文件夹/文件 操作</h2><h3 id="文件夹-文件检查"><a href="#文件夹-文件检查" class="headerlink" title="文件夹/文件检查"></a>文件夹/文件检查</h3><p>主要是 <code>Directory</code> / <code>File</code> / <code>DirectoryInfo</code> / <code>FileInfo</code> 几个类来操作检查。</p>
<p><strong>注：Path是路径字符串的拼接、剪切、检查操作类，并不会执行IO操作。</strong></p>
<h3 id="文件夹-文件新增"><a href="#文件夹-文件新增" class="headerlink" title="文件夹/文件新增"></a>文件夹/文件新增</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Directory.CreateDirectory(path);<span class="comment">//新增</span></span><br><span class="line">File.Create(path);<span class="comment">//新增或覆盖</span></span><br><span class="line">File.AppendText(path);<span class="comment">//新增或追加</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>文件夹新增时，dotnet会自动逐层创建，例如“C:\test1\test2”，“test1”文件夹不存在会先创建“test1”文件夹。</p>
</blockquote>
<h3 id="文件夹-文件复制"><a href="#文件夹-文件复制" class="headerlink" title="文件夹/文件复制"></a>文件夹/文件复制</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件夹无法复制</span></span><br><span class="line">File.Copy(path1, path2);</span><br></pre></td></tr></table></figure>
<h3 id="文件夹-文件移动"><a href="#文件夹-文件移动" class="headerlink" title="文件夹/文件移动"></a>文件夹/文件移动</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Directory.Move(path1, path2);</span><br><span class="line">File.Move(path1, path2);</span><br></pre></td></tr></table></figure>
<h3 id="文件夹-文件删除"><a href="#文件夹-文件删除" class="headerlink" title="文件夹/文件删除"></a>文件夹/文件删除</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Directory.Delete(path, <span class="literal">true</span>);<span class="comment">//第二个参数是指定是否删除目录内文件夹与文件 若不指定默认false 当为false文件夹内存在文件或文件夹会报错</span></span><br><span class="line">File.Delete(path);</span><br></pre></td></tr></table></figure>
<h2 id="文件写入-读取"><a href="#文件写入-读取" class="headerlink" title="文件写入/读取"></a>文件写入/读取</h2><h3 id="常见写入方法："><a href="#常见写入方法：" class="headerlink" title="常见写入方法："></a>常见写入方法：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增或覆盖</span></span><br><span class="line"><span class="keyword">using</span> (FileStream fileStream = File.Create(path))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> sText = <span class="string">&quot;My name is Li Lei.&quot;</span>;</span><br><span class="line">    <span class="built_in">byte</span>[] bytes = Encoding.Default.GetBytes(sText);</span><br><span class="line">    fileStream.Write(bytes, <span class="number">0</span>, bytes.Length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增或覆盖</span></span><br><span class="line"><span class="keyword">using</span> (FileStream fileStream = File.Create(path))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (StreamWriter streamWriter = <span class="keyword">new</span> StreamWriter(fileStream))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> sText = <span class="string">&quot;My name is Han Meimei.&quot;</span>;</span><br><span class="line">        streamWriter.Write(sText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增或追加</span></span><br><span class="line"><span class="keyword">using</span> (StreamWriter streamWriter = File.AppendText(path))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> sText = <span class="string">&quot;Nice to meet you.&quot;</span>;</span><br><span class="line">    <span class="built_in">byte</span>[] bytes = Encoding.Default.GetBytes(sText);</span><br><span class="line">    streamWriter.BaseStream.Write(bytes, <span class="number">0</span>, bytes.Length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增或追加</span></span><br><span class="line"><span class="keyword">using</span> (StreamWriter streamWriter = File.AppendText(path))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> sText = <span class="string">&quot;Nice to meet you too.&quot;</span>;</span><br><span class="line">    streamWriter.Write(sText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常见读取方法："><a href="#常见读取方法：" class="headerlink" title="常见读取方法："></a>常见读取方法：</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次读取</span></span><br><span class="line"><span class="built_in">byte</span>[] bytes = File.ReadAllBytes(path);</span><br><span class="line"><span class="built_in">string</span> sText = File.ReadAllText(path);</span><br><span class="line"><span class="built_in">string</span>[] aLineText = File.ReadAllLines(path);</span><br><span class="line">IEnumerable&lt;<span class="built_in">string</span>&gt; listLineText = File.ReadLines(path);</span><br><span class="line"><span class="comment">//大文件读取</span></span><br><span class="line"><span class="keyword">using</span> (FileStream fileStream = File.OpenRead(path))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> length = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[length];</span><br><span class="line">        result = fileStream.Read(bytes, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(Encoding.Default.GetString(bytes));</span><br><span class="line">    &#125; <span class="keyword">while</span> (length == result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DriveInfo[] aInfo = DriveInfo.GetDrives();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> info <span class="keyword">in</span> aInfo)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;----------------------------------------------------&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;驱动器的名称：&quot;</span> + info.Name);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;驱动器根目录：&quot;</span> + info.RootDirectory);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;指示驱动器上可用空闲空间总量：&quot;</span> + info.AvailableFreeSpace);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;文件系统名称：&quot;</span> + info.DriveFormat);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;驱动器类型：&quot;</span> + info.DriveType);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;获取一个指示驱动器是否已经准备好：&quot;</span> + info.IsReady);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;获取驱动器上可用空闲空间总量：&quot;</span> + info.TotalFreeSpace);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;获取驱动器空间总大小：&quot;</span> + info.TotalSize);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;获取或设置驱动器的卷标：&quot;</span> + info.VolumeLabel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这部分原本感觉没必要提交上来，因为这部分内容太太基础。</p>
<p>但是实际工作中，经常会遗忘一部分方法怎么使用，所以提交上来供以后查阅。</p>
<p>另外由于经常翻看前辈代码，IO有部分需要特别注意一下：</p>
<ul>
<li>多线程操作文件读写，一定要加锁，尽量避免使用<code>try</code>处理文件被占用引发的异常；</li>
<li>文件夹创建碰到多层级无需逐层创建，dotnet底层会自动帮我们逐层创建；</li>
<li>记录日志文件，内容使用流操作写文件，直接使用 <code>File.AppendText()</code> 方法即可，而且不用判断文件是否存在，dotnet会在不存在时自动帮我们创建；</li>
</ul>
<p>先写这些，有些细节以后想到了再补。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/file-operations-in-csharp" data-id="cklbzl1am001czonubc6vbvi3" data-title="C#中的文件操作" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-anonymous-type-extension-method-var-dynamic" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/anonymous-type-extension-method-var-dynamic" class="article-date">
  <time class="dt-published" datetime="2019-04-02T09:33:00.000Z" itemprop="datePublished">2019-04-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a>►<a class="article-category-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/anonymous-type-extension-method-var-dynamic">匿名类型、扩展方法、var、dynamic</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h2><p><code>C#</code>在<code>3.0</code>版本以后，允许使用<code>new</code>关键字直接创造对象，方便我们在临时使用一特定类型时，无需单独的创建一个类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> user = <span class="keyword">new</span></span><br><span class="line">&#123;</span><br><span class="line">    Id = <span class="number">1</span>,</span><br><span class="line">    Name = <span class="string">&quot;Kangkang&quot;</span>,</span><br><span class="line">    Age = <span class="number">12</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Console.WriteLine(user.Id);//无法获取 因为是object类型 该问题可以使用var关键字解决</span></span><br></pre></td></tr></table></figure>
<h2 id="var-关键字"><a href="#var-关键字" class="headerlink" title="var 关键字"></a>var 关键字</h2><p>在方法范围内声明的变量可以具有隐式“类型” <code>var</code>。</p>
<p>隐式类型本地变量为强类型，就像用户已经自行声明该类型，但编译器决定类型一样(语法糖)。</p>
<h3 id="声明现有类型"><a href="#声明现有类型" class="headerlink" title="声明现有类型"></a>声明现有类型</h3><p>编译器会自行推断左侧变量的类型，如下代码编译器会识别为<code>int</code>类型：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="声明匿名类型"><a href="#声明匿名类型" class="headerlink" title="声明匿名类型"></a>声明匿名类型</h3><p>创建的匿名类型我们并不知道编译器为我们生成的类型名称，但是我们可以使用<code>var</code>关键字让编译器自己根据编译的结果来推断：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span></span><br><span class="line">&#123;</span><br><span class="line">    Id = <span class="number">1</span>,</span><br><span class="line">    Name = <span class="string">&quot;Kangkang&quot;</span>,</span><br><span class="line">    Age = <span class="number">12</span></span><br><span class="line">&#125;;</span><br><span class="line">Console.WriteLine(user.Id);</span><br></pre></td></tr></table></figure>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>必须在定义时初始化，也就是必须是 <code>var s = &quot;abcd&quot;</code> 形式</li>
<li>一但初始化完成，就不能再给变量赋与初始化值类型不同的值</li>
<li>var要求是局部变量</li>
<li>使用var定义变量和object不同，它在效率上和使用强类型方式定义变量完全一样</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;**************** 匿名类型与var ****************&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> user = <span class="keyword">new</span></span><br><span class="line">    &#123;</span><br><span class="line">        Id = <span class="number">1</span>,</span><br><span class="line">        Name = <span class="string">&quot;Kangkang&quot;</span>,</span><br><span class="line">        Age = <span class="number">12</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//user.Name = &quot;Xiaoming&quot;;//匿名类型属性只读</span></span><br><span class="line">    Type type = user.GetType();</span><br><span class="line">    <span class="keyword">var</span> properties = type.GetProperties();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> properties)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//只读属性反射也无法修改属性值</span></span><br><span class="line">        <span class="comment">//if (item.Name == &quot;Name&quot;)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    item.SetValue(user, &quot;Xiaoming&quot;, null);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Property name is <span class="subst">&#123;item.Name&#125;</span>, value is <span class="subst">&#123;item.GetValue(user, <span class="literal">null</span>)&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>静态类里的静态方法，第一个参数类型前加this关键字  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtensionClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Human <span class="title">CheckHuman</span>(<span class="params"><span class="keyword">this</span> Human human</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        human = human ?? <span class="keyword">new</span> Human(<span class="string">&quot;Kangkang&quot;</span>,<span class="string">&quot;China&quot;</span>);</span><br><span class="line">        human.Name = <span class="built_in">string</span>.IsNullOrEmpty(human.Name) ? <span class="string">&quot;EmptyName&quot;</span> : human.Name;</span><br><span class="line">        human.Country = <span class="built_in">string</span>.IsNullOrEmpty(human.Country) ? <span class="string">&quot;China&quot;</span> : human.Country;</span><br><span class="line">        <span class="keyword">return</span> human;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，在不修改类型封装的前提下，给类型额外的扩展一个方法（密封类也可以），扩展的方法为实例方法。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>既然为实例方法，我们便可以像实例方法一样调用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;**************** 扩展方法的使用 ****************&quot;</span>);</span><br><span class="line">    Human human = <span class="literal">null</span>;</span><br><span class="line">    human.CheckHuman().SayHi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果与实例方法相同，优先实例方法；不能滥用扩展方法，尤其是基类型。</p>
<h2 id="dynamic"><a href="#dynamic" class="headerlink" title="dynamic"></a>dynamic</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>dynamic</code> 类型是一种静态类型，但类型为 <code>dynamic</code> 的对象会跳过静态类型检查。 大多数情况下，该对象就像具有类型 <code>object</code> 一样。 在编译时，将假定类型化为 <code>dynamic</code> 的元素支持任何操作。 因此，您不必考虑对象是从 <code>COM</code> <code>API</code>、从动态语言（例如 <code>IronPython</code>）、从 <code>HTML</code> 文档对象模型 (DOM)、从反射还是从程序中的其他位置获取自己的值。 但是，如果代码无效，则在运行时会捕获到错误。</p>
<h3 id="与-var-对比"><a href="#与-var-对比" class="headerlink" title="与 var 对比"></a>与 <code>var</code> 对比</h3><p>一旦被编译，编译期会自动匹配var 变量的实际类型，并用实际类型来替换该变量的申明，这看上去就好像我们在编码的时候是用实际类型进行申明的。<br>而dynamic被编译后，实际是一个object类型，只不过编译器会对dynamic类型进行特殊处理，让它在编译期间不进行任何的类型检查，而是将类型检查放到了运行期。  </p>
<p>以 <code>var</code> 声明的变量，支持“智能感知”，因为 <code>Visual Studio</code> 能推断出 <code>var</code> 类型的实际类型，而以 <code>dynamic</code> 声明的变量却不支持“智能感知”，因为编译器对其运行期的类型一无所知。对 <code>dynamic</code> 变量使用“智能感知”，会提示“此操作将在运行时解析”。</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic</span> para = <span class="keyword">new</span> System.Dynamic.ExpandoObject();</span><br><span class="line">para.name = <span class="string">&quot;Kangkang&quot;</span>;</span><br><span class="line">para.country = <span class="string">&quot;China&quot;</span>;</span><br><span class="line">para.age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接调用</span></span><br><span class="line">Console.WriteLine(para.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以重新赋值其他类型</span></span><br><span class="line">para.name = <span class="number">007</span>;</span><br><span class="line">Console.WriteLine(para.name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以理解其为一个特殊的字典 我们可以使用字典的方式遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> para <span class="keyword">as</span> IDictionary&lt;<span class="built_in">string</span>, <span class="built_in">object</span>&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;item.Key&#125;</span> <span class="subst">&#123;item.Value&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用不存在的“属性”编译时不会报错 但是运行时会报错</span></span><br><span class="line"><span class="comment">// Microsoft.CSharp.RuntimeBinder.RuntimeBinderException:“&#x27;System.Dynamic.ExpandoObject&#x27; does not contain a definition for &#x27;hobby&#x27;”</span></span><br><span class="line">Console.WriteLine(para.hobby);</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/anonymous-type-extension-method-var-dynamic" data-id="cklbzl19k0000zonucpnkaq7u" data-title="匿名类型、扩展方法、var、dynamic" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/">开发</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/C/">C#</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/C/ASP-NET-Core/">ASP.NET Core</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/C/WPF/">WPF</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E4%B8%9A%E5%8A%A1/">业务</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E5%9F%BA%E7%A1%80/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/Oracle/">Oracle</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/PostgreSQL/">PostgreSQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E5%BA%93/SQLite/">SQLite</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BC%80%E5%8F%91/%E6%9D%82%E8%B0%88/">杂谈</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MacOS/">MacOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%B7%A5%E5%85%B7/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E4%BB%B6/">软件</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%BF%97/">日志</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%BF%97/%E5%85%AC%E5%91%8A/">公告</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%BF%97/%E5%BC%80%E7%AE%B1/">开箱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%BF%97/%E6%9D%82%E8%B0%88/">杂谈</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NET-Standard/" rel="tag">.NET Standard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ASCII/" rel="tag">ASCII</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ActiveX/" rel="tag">ActiveX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Attribute/" rel="tag">Attribute</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Autofac/" rel="tag">Autofac</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BFG/" rel="tag">BFG</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCProxy/" rel="tag">CCProxy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome/" rel="tag">Chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DBeaver/" rel="tag">DBeaver</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Expression/" rel="tag">Expression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fody/" rel="tag">Fody</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GDI/" rel="tag">GDI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gitea/" rel="tag">Gitea</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HIS/" rel="tag">HIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HongYang/" rel="tag">HongYang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/" rel="tag">IDE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IE/" rel="tag">IE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jint/" rel="tag">Jint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Json/" rel="tag">Json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kindle/" rel="tag">Kindle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LIS/" rel="tag">LIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LODOP/" rel="tag">LODOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVC/" rel="tag">MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MacOS/" rel="tag">MacOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/" rel="tag">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NHibernate/" rel="tag">NHibernate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nexus3/" rel="tag">Nexus3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Note/" rel="tag">Note</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NuGet/" rel="tag">NuGet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOP/" rel="tag">OOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Oracle/" rel="tag">Oracle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SOA/" rel="tag">SOA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell/" rel="tag">Shell</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCP/" rel="tag">TCP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Telegram/" rel="tag">Telegram</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TreeView/" rel="tag">TreeView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tuple/" rel="tag">Tuple</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UI/" rel="tag">UI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/" rel="tag">UML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VS/" rel="tag">VS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VSCode/" rel="tag">VSCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ValueTuple/" rel="tag">ValueTuple</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WCF/" rel="tag">WCF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WPF/" rel="tag">WPF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebApi/" rel="tag">WebApi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebService/" rel="tag">WebService</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WinForm/" rel="tag">WinForm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows/" rel="tag">Windows</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Windows-XP/" rel="tag">Windows XP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xml/" rel="tag">Xml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/decimal/" rel="tag">decimal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/frp/" rel="tag">frp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbc/" rel="tag">jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mstsc/" rel="tag">mstsc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%B2%E5%8F%A3/" rel="tag">串口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" rel="tag">依赖注入</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%83%E7%BB%84/" rel="tag">元组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A0%E5%AF%86/" rel="tag">加密</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" rel="tag">动态链接库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A7%94%E6%89%98/" rel="tag">委托</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B4%E9%BE%84/" rel="tag">年龄</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" rel="tag">序列化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%83%E5%85%83/" rel="tag">弃元</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%89%93%E5%8D%B0/" rel="tag">打印</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" rel="tag">构造函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" rel="tag">析构函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%9A%E4%B8%BE/" rel="tag">枚举</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99/" rel="tag">正则</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag">泛型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%91%9E%E7%BE%8E/" rel="tag">瑞美</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%80%E7%90%83%E4%BB%AA/" rel="tag">血球仪</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E6%9E%84%E5%87%BD%E6%95%B0/" rel="tag">解构函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B0%83%E8%AF%95/" rel="tag">调试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%9D%E5%85%8B%E6%9B%BC/" rel="tag">贝克曼</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%BB%E5%8D%A1/" rel="tag">身份证读卡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6/" rel="tag">软件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9C%E7%A8%8B/" rel="tag">远程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%97%AA%E9%80%80/" rel="tag">闪退</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/NET-Standard/" style="font-size: 10px;">.NET Standard</a> <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/ASCII/" style="font-size: 10px;">ASCII</a> <a href="/tags/ActiveX/" style="font-size: 10px;">ActiveX</a> <a href="/tags/Attribute/" style="font-size: 10px;">Attribute</a> <a href="/tags/Autofac/" style="font-size: 10px;">Autofac</a> <a href="/tags/BFG/" style="font-size: 10px;">BFG</a> <a href="/tags/CCProxy/" style="font-size: 10px;">CCProxy</a> <a href="/tags/Chrome/" style="font-size: 10px;">Chrome</a> <a href="/tags/DBeaver/" style="font-size: 12.5px;">DBeaver</a> <a href="/tags/Expression/" style="font-size: 10px;">Expression</a> <a href="/tags/Fody/" style="font-size: 10px;">Fody</a> <a href="/tags/GDI/" style="font-size: 10px;">GDI</a> <a href="/tags/Git/" style="font-size: 12.5px;">Git</a> <a href="/tags/GitHub/" style="font-size: 12.5px;">GitHub</a> <a href="/tags/Gitea/" style="font-size: 10px;">Gitea</a> <a href="/tags/HIS/" style="font-size: 12.5px;">HIS</a> <a href="/tags/HongYang/" style="font-size: 10px;">HongYang</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/IE/" style="font-size: 10px;">IE</a> <a href="/tags/JavaScript/" style="font-size: 12.5px;">JavaScript</a> <a href="/tags/Jint/" style="font-size: 12.5px;">Jint</a> <a href="/tags/Json/" style="font-size: 10px;">Json</a> <a href="/tags/Kindle/" style="font-size: 10px;">Kindle</a> <a href="/tags/LIS/" style="font-size: 15px;">LIS</a> <a href="/tags/LODOP/" style="font-size: 10px;">LODOP</a> <a href="/tags/MVC/" style="font-size: 10px;">MVC</a> <a href="/tags/MacOS/" style="font-size: 10px;">MacOS</a> <a href="/tags/Math/" style="font-size: 10px;">Math</a> <a href="/tags/NHibernate/" style="font-size: 10px;">NHibernate</a> <a href="/tags/Nexus3/" style="font-size: 10px;">Nexus3</a> <a href="/tags/Note/" style="font-size: 10px;">Note</a> <a href="/tags/NuGet/" style="font-size: 10px;">NuGet</a> <a href="/tags/OOP/" style="font-size: 10px;">OOP</a> <a href="/tags/Oracle/" style="font-size: 10px;">Oracle</a> <a href="/tags/SOA/" style="font-size: 17.5px;">SOA</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/Shell/" style="font-size: 10px;">Shell</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/Telegram/" style="font-size: 10px;">Telegram</a> <a href="/tags/TreeView/" style="font-size: 10px;">TreeView</a> <a href="/tags/Tuple/" style="font-size: 10px;">Tuple</a> <a href="/tags/UI/" style="font-size: 10px;">UI</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/VS/" style="font-size: 10px;">VS</a> <a href="/tags/VSCode/" style="font-size: 10px;">VSCode</a> <a href="/tags/ValueTuple/" style="font-size: 10px;">ValueTuple</a> <a href="/tags/WCF/" style="font-size: 12.5px;">WCF</a> <a href="/tags/WPF/" style="font-size: 10px;">WPF</a> <a href="/tags/WebApi/" style="font-size: 15px;">WebApi</a> <a href="/tags/WebService/" style="font-size: 15px;">WebService</a> <a href="/tags/WinForm/" style="font-size: 10px;">WinForm</a> <a href="/tags/Windows/" style="font-size: 10px;">Windows</a> <a href="/tags/Windows-XP/" style="font-size: 12.5px;">Windows XP</a> <a href="/tags/Xml/" style="font-size: 10px;">Xml</a> <a href="/tags/decimal/" style="font-size: 10px;">decimal</a> <a href="/tags/frp/" style="font-size: 10px;">frp</a> <a href="/tags/jdbc/" style="font-size: 10px;">jdbc</a> <a href="/tags/mstsc/" style="font-size: 10px;">mstsc</a> <a href="/tags/%E4%B8%B2%E5%8F%A3/" style="font-size: 10px;">串口</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 12.5px;">代理</a> <a href="/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/" style="font-size: 10px;">依赖注入</a> <a href="/tags/%E5%85%83%E7%BB%84/" style="font-size: 12.5px;">元组</a> <a href="/tags/%E5%8A%A0%E5%AF%86/" style="font-size: 10px;">加密</a> <a href="/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" style="font-size: 10px;">动态链接库</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 10px;">反射</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 20px;">多线程</a> <a href="/tags/%E5%A7%94%E6%89%98/" style="font-size: 10px;">委托</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E5%B9%B4%E9%BE%84/" style="font-size: 10px;">年龄</a> <a href="/tags/%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size: 10px;">序列化</a> <a href="/tags/%E5%BC%83%E5%85%83/" style="font-size: 10px;">弃元</a> <a href="/tags/%E6%89%93%E5%8D%B0/" style="font-size: 10px;">打印</a> <a href="/tags/%E6%97%A5%E5%BF%97/" style="font-size: 10px;">日志</a> <a href="/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" style="font-size: 10px;">构造函数</a> <a href="/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" style="font-size: 10px;">析构函数</a> <a href="/tags/%E6%9E%9A%E4%B8%BE/" style="font-size: 10px;">枚举</a> <a href="/tags/%E6%AD%A3%E5%88%99/" style="font-size: 15px;">正则</a> <a href="/tags/%E6%B3%9B%E5%9E%8B/" style="font-size: 12.5px;">泛型</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%91%9E%E7%BE%8E/" style="font-size: 10px;">瑞美</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 12.5px;">虚拟机</a> <a href="/tags/%E8%A1%80%E7%90%83%E4%BB%AA/" style="font-size: 10px;">血球仪</a> <a href="/tags/%E8%A7%A3%E6%9E%84%E5%87%BD%E6%95%B0/" style="font-size: 10px;">解构函数</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 12.5px;">设计模式</a> <a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 10px;">调试</a> <a href="/tags/%E8%B4%9D%E5%85%8B%E6%9B%BC/" style="font-size: 10px;">贝克曼</a> <a href="/tags/%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%BB%E5%8D%A1/" style="font-size: 10px;">身份证读卡</a> <a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 10px;">软件</a> <a href="/tags/%E8%BF%9C%E7%A8%8B/" style="font-size: 10px;">远程</a> <a href="/tags/%E9%97%AA%E9%80%80/" style="font-size: 10px;">闪退</a> <a href="/tags/%E9%A1%B9%E7%9B%AE/" style="font-size: 10px;">项目</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/csharp-expression-script-evaluation-problems">C# 中表达式计算问题</a>
          </li>
        
          <li>
            <a href="/aspnet-core-001-source-code-compilation-and-debugging">ASP.NET Core - 001 源码编译与调试</a>
          </li>
        
          <li>
            <a href="/aspnet-core-000-development-environment-configuration">ASP.NET Core - 000 开发环境配置</a>
          </li>
        
          <li>
            <a href="/dotnet-core-migration-web-service">迁移 Web Service 项目到 .NET Core</a>
          </li>
        
          <li>
            <a href="/his-development-environment">环境部署</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 hd2y<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>